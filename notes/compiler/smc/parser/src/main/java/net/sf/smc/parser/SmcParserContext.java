/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : SmcParser.sm
 */


/*
 * The contents of this file are subject to the Mozilla Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code is State Machine Compiler (SMC).
 *
 * The Initial Developer of the Original Code is Charles W. Rapp.
 * Portions created by Charles W. Rapp are
 * Copyright (C) 2000 - 2005, 2008, 2013. Charles W. Rapp.
 * All Rights Reserved.
 *
 * Contributor(s):
 *   Eitan Suez contributed examples/Ant.
 *   (Name withheld) contributed the C# code generation and
 *   examples/C#.
 *   Francois Perrad contributed the Python code generation and
 *   examples/Python, Perl code generation and examples/Perl,
 *   Ruby code generation and examples/Ruby, Lua code generation
 *   and examples/Lua, Groovy code generation and examples/Groovy.
 *   Chris Liscio contributed the Objective-C code generation
 *   and examples/ObjC.
 *
 * smcParser --
 *
 *  This state machine defines the  state machine language.
 *
 * RCS ID
 * $Id: SmcParser.sm,v 1.10 2015/08/02 19:44:36 cwrapp Exp $
 *
 * CHANGE LOG
 * $Log: SmcParser.sm,v $
 * Revision 1.10  2015/08/02 19:44:36  cwrapp
 * Release 6.6.0 commit.
 *
 * Revision 1.9  2013/12/15 16:31:20  fperrad
 * full refactor of JavaScript
 *
 * Revision 1.8  2013/07/14 14:32:39  cwrapp
 * check in for release 6.2.0
 *
 * Revision 1.7  2010/03/05 21:29:54  fperrad
 * Allows property with Groovy, Lua, Perl, Python, Ruby & Scala
 *
 * Revision 1.6  2010/03/03 19:18:41  fperrad
 * fix property with Graph & Table
 *
 * Revision 1.5  2009/09/12 21:44:49  kgreg99
 * Implemented feature req. #2718941 - user defined generated class name.
 * A new statement was added to the syntax: %fsmclass class_name
 * It is optional. If not used, generated class is called as before "XxxContext" where Xxx is context class name as entered via %class statement.
 * If used, generated class is called asrequested.
 * Following language generators are touched:
 * c, c++, java, c#, objc, lua, groovy, scala, tcl, VB
 * This feature is not tested yet !
 * Maybe it will be necessary to modify also the output file name.
 *
 * Revision 1.4  2009/04/11 13:11:13  cwrapp
 * Corrected raw mode 3 to handle multiple argument template/generic declarations.
 *
 * Revision 1.3  2009/03/27 09:41:47  cwrapp
 * Added F. Perrad changes back in.
 *
 * Revision 1.2  2009/03/03 17:28:53  kgreg99
 * 1. Bugs resolved:
 * #2657779 - modified SmcParser.sm and SmcParserContext.java
 * #2648516 - modified SmcCSharpGenerator.java
 * #2648472 - modified SmcSyntaxChecker.java
 * #2648469 - modified SmcMap.java
 *
 * Revision 1.1  2009/03/01 18:20:42  cwrapp
 * Preliminary v. 6.0.0 commit.
 *
 * Revision 1.21  2008/08/16 14:31:37  fperrad
 * + detabify
 *
 * Revision 1.20  2008/04/22 16:05:24  fperrad
 * - add PHP language (patch from Toni Arnold)
 *
 * Revision 1.19  2008/01/22 08:56:55  fperrad
 * - fix : allows Perl parameter with graph generation
 *
 * Revision 1.18  2007/11/19 18:53:21  fperrad
 * + add : jump syntax
 *   jump uses the same syntax as push,
 *   allows transition between states of different maps but without stacking a return context.
 *
 * Revision 1.17  2007/07/16 06:28:06  fperrad
 * + Added Groovy generator.
 *
 * Revision 1.16  2007/02/21 13:56:16  cwrapp
 * Moved Java code to release 1.5.0
 *
 * Revision 1.15  2007/01/15 00:23:51  cwrapp
 * Release 4.4.0 initial commit.
 *
 * Revision 1.14  2007/01/03 15:23:05  fperrad
 * + Added Lua generator.
 *
 * Revision 1.13  2006/09/16 15:04:29  cwrapp
 * Initial v. 4.3.3 check-in.
 *
 * Revision 1.12  2006/07/11 18:17:01  cwrapp
 * Removed errors regarding percent keywords.
 *
 * Revision 1.11  2006/04/22 12:45:26  cwrapp
 * Version 4.3.1
 *
 * Revision 1.10  2005/09/14 01:51:33  cwrapp
 * Changes in release 4.2.0:
 * New features:
 *
 * None.
 *
 * Fixed the following bugs:
 *
 * + (Java) -java broken due to an untested minor change.
 *
 * Revision 1.9  2005/08/26 15:21:34  cwrapp
 * Final commit for release 4.2.0. See README.txt for more information.
 *
 * Revision 1.8  2005/07/07 12:11:56  fperrad
 * Add a new token '$' for Perl language.
 * The type of parameter is optional for Python, Per & Ruby.
 *
 * Revision 1.7  2005/06/30 10:44:23  cwrapp
 * Added %access keyword which allows developers to set the generate Context
 * class' accessibility level in Java and C#.
 *
 * Revision 1.6  2005/05/28 19:28:42  cwrapp
 * Moved to visitor pattern.
 *
 * Revision 1.5  2005/02/21 15:37:52  charlesr
 * Added Francois Perrad to Contributors section for Python work.
 *
 * Revision 1.4  2005/02/21 15:21:21  charlesr
 * Added -graph target as allowing %include, %declare and %import.
 *
 * Revision 1.3  2005/02/03 17:06:21  charlesr
 * SmcParser.warning() and .error() methods now take a line
 * number argument. All calls to these method within the
 * parser's FSM have been modified.
 *
 * Revision 1.2  2004/09/06 16:41:32  charlesr
 * Added "property = value" syntax. Added C# support.
 *
 * Revision 1.1  2004/05/31 13:56:34  charlesr
 * Added support for VB.net code generation.
 *
 * Revision 1.0  2003/12/14 21:06:00  charlesr
 * Initial revision
 *
 */


package net.sf.smc.parser;

import java.util.List;
import net.sf.smc.model.SmcAction;
import net.sf.smc.model.SmcElement.TransType;
import net.sf.smc.model.SmcParameter;
import net.sf.smc.model.TargetLanguage;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodHandles.Lookup;
import java.lang.invoke.MethodType;
import statemap.FSMContext7;
import statemap.State7;
import statemap.TransitionHandle;

public class SmcParserContext
    extends FSMContext7
{
//---------------------------------------------------------------
// Member methods.
//

    //-----------------------------------------------------------
    // Constructors.
    //

    public SmcParserContext(final SmcParser owner)
    {
        this (owner, sStates[ParserMap_Start_STATE_ID]);
    }

    public SmcParserContext(final SmcParser owner, final int initStateId)
    {
        this (owner, sStates[initStateId]);    }

    public SmcParserContext(final SmcParser owner, final State7 initState)
    {
        super (initState);

        ctxt = owner;
    }

    //
    // end of Constructors.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // FSMContext7 Abstract Method Override.
    //

    @Override
    protected void executeAction(final MethodHandle mh)
    {
        try
        {
            mh.invokeExact(this);
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
    }

    //
    // end of FSMContext7 Abstract Method Override.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // Transitions.
    //

    public void ACCESS(SmcLexer.Token token)
    {
        mTransition = "ACCESS";
        try
        {
            final TransitionHandle th =
                getState().transition(ACCESS11_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void CLASS_NAME(SmcLexer.Token token)
    {
        mTransition = "CLASS_NAME";
        try
        {
            final TransitionHandle th =
                getState().transition(CLASS_NAME3_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void COLON(SmcLexer.Token token)
    {
        mTransition = "COLON";
        try
        {
            final TransitionHandle th =
                getState().transition(COLON34_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void COMMA(SmcLexer.Token token)
    {
        mTransition = "COMMA";
        try
        {
            final TransitionHandle th =
                getState().transition(COMMA32_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void DECLARE(SmcLexer.Token token)
    {
        mTransition = "DECLARE";
        try
        {
            final TransitionHandle th =
                getState().transition(DECLARE10_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void DOLLAR(SmcLexer.Token token)
    {
        mTransition = "DOLLAR";
        try
        {
            final TransitionHandle th =
                getState().transition(DOLLAR33_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void ENTRY(SmcLexer.Token token)
    {
        mTransition = "ENTRY";
        try
        {
            final TransitionHandle th =
                getState().transition(ENTRY16_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void EOD(SmcLexer.Token token)
    {
        mTransition = "EOD";
        try
        {
            final TransitionHandle th =
                getState().transition(EOD15_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void EQUAL(SmcLexer.Token token)
    {
        mTransition = "EQUAL";
        try
        {
            final TransitionHandle th =
                getState().transition(EQUAL19_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void EXIT(SmcLexer.Token token)
    {
        mTransition = "EXIT";
        try
        {
            final TransitionHandle th =
                getState().transition(EXIT17_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void FSM_CLASS_NAME(SmcLexer.Token token)
    {
        mTransition = "FSM_CLASS_NAME";
        try
        {
            final TransitionHandle th =
                getState().transition(FSM_CLASS_NAME4_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void FSM_FILE_NAME(SmcLexer.Token token)
    {
        mTransition = "FSM_FILE_NAME";
        try
        {
            final TransitionHandle th =
                getState().transition(FSM_FILE_NAME5_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void HEADER_FILE(SmcLexer.Token token)
    {
        mTransition = "HEADER_FILE";
        try
        {
            final TransitionHandle th =
                getState().transition(HEADER_FILE6_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void IMPORT(SmcLexer.Token token)
    {
        mTransition = "IMPORT";
        try
        {
            final TransitionHandle th =
                getState().transition(IMPORT9_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void INCLUDE_FILE(SmcLexer.Token token)
    {
        mTransition = "INCLUDE_FILE";
        try
        {
            final TransitionHandle th =
                getState().transition(INCLUDE_FILE7_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void JUMP(SmcLexer.Token token)
    {
        mTransition = "JUMP";
        try
        {
            final TransitionHandle th =
                getState().transition(JUMP27_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void LEFT_BRACE(SmcLexer.Token token)
    {
        mTransition = "LEFT_BRACE";
        try
        {
            final TransitionHandle th =
                getState().transition(LEFT_BRACE18_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void LEFT_BRACKET(SmcLexer.Token token)
    {
        mTransition = "LEFT_BRACKET";
        try
        {
            final TransitionHandle th =
                getState().transition(LEFT_BRACKET24_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void LEFT_PAREN(SmcLexer.Token token)
    {
        mTransition = "LEFT_PAREN";
        try
        {
            final TransitionHandle th =
                getState().transition(LEFT_PAREN23_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void MAP_NAME(SmcLexer.Token token)
    {
        mTransition = "MAP_NAME";
        try
        {
            final TransitionHandle th =
                getState().transition(MAP_NAME12_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void PACKAGE_NAME(SmcLexer.Token token)
    {
        mTransition = "PACKAGE_NAME";
        try
        {
            final TransitionHandle th =
                getState().transition(PACKAGE_NAME8_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void POP(SmcLexer.Token token)
    {
        mTransition = "POP";
        try
        {
            final TransitionHandle th =
                getState().transition(POP26_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void PUSH(SmcLexer.Token token)
    {
        mTransition = "PUSH";
        try
        {
            final TransitionHandle th =
                getState().transition(PUSH25_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void RIGHT_BRACE(SmcLexer.Token token)
    {
        mTransition = "RIGHT_BRACE";
        try
        {
            final TransitionHandle th =
                getState().transition(RIGHT_BRACE22_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void RIGHT_PAREN(SmcLexer.Token token)
    {
        mTransition = "RIGHT_PAREN";
        try
        {
            final TransitionHandle th =
                getState().transition(RIGHT_PAREN31_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void SEMICOLON(SmcLexer.Token token)
    {
        mTransition = "SEMICOLON";
        try
        {
            final TransitionHandle th =
                getState().transition(SEMICOLON37_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void SLASH(SmcLexer.Token token)
    {
        mTransition = "SLASH";
        try
        {
            final TransitionHandle th =
                getState().transition(SLASH30_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void SOURCE(SmcLexer.Token token)
    {
        mTransition = "SOURCE";
        try
        {
            final TransitionHandle th =
                getState().transition(SOURCE1_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void START_STATE(SmcLexer.Token token)
    {
        mTransition = "START_STATE";
        try
        {
            final TransitionHandle th =
                getState().transition(START_STATE2_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void WORD(SmcLexer.Token token)
    {
        mTransition = "WORD";
        try
        {
            final TransitionHandle th =
                getState().transition(WORD14_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void actionsDone(List<SmcAction> actions, int lineNumber)
    {
        mTransition = "actionsDone";
        try
        {
            final TransitionHandle th =
                getState().transition(actionsDone20_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, actions, lineNumber);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void actionsError()
    {
        mTransition = "actionsError";
        try
        {
            final TransitionHandle th =
                getState().transition(actionsError21_TRANSITION_ID);

            (th.handle()).invokeExact(this);
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void argsDone(List<String> args)
    {
        mTransition = "argsDone";
        try
        {
            final TransitionHandle th =
                getState().transition(argsDone35_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, args);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void argsError()
    {
        mTransition = "argsError";
        try
        {
            final TransitionHandle th =
                getState().transition(argsError36_TRANSITION_ID);

            (th.handle()).invokeExact(this);
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void paramsDone(List<SmcParameter> params, int lineNumber)
    {
        mTransition = "paramsDone";
        try
        {
            final TransitionHandle th =
                getState().transition(paramsDone28_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, params, lineNumber);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    public void paramsError(List<SmcParameter> params, int lineNumber)
    {
        mTransition = "paramsError";
        try
        {
            final TransitionHandle th =
                getState().transition(paramsError29_TRANSITION_ID);

            if (th.isDefault())
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, params, lineNumber);
            }
        }
        catch (Throwable tex)
        {
            debugOutput(tex);
        }
        mTransition = "";
    }

    //
    // end of Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Start State Transitions.
    //

    private void ParserMap_Start_ACCESS(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Start.ACCESS(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Start.ACCESS(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Access_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Access.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Access.entry()");

    }


    private void ParserMap_Start_CLASS_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Start.CLASS_NAME(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Start.CLASS_NAME(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Context_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Context.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Context.entry()");

    }


    private void ParserMap_Start_DECLARE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Start.DECLARE(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Start.DECLARE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Declare_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Declare.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Declare.entry()");

    }


    private void ParserMap_Start_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Start.Default()");

            clearState();
            ctxt.error("Expecting \"%{ source %}\", %start, or %class.", ctxt.getLineNumber());
            ctxt.setHeaderLine(ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Start.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_StartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StartError.entry()");

    }


    private void ParserMap_Start_FSM_CLASS_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Start.FSM_CLASS_NAME(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Start.FSM_CLASS_NAME(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_FsmClassName_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : FsmClassName.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : FsmClassName.entry()");

    }


    private void ParserMap_Start_FSM_FILE_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Start.FSM_FILE_NAME(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Start.FSM_FILE_NAME(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_FsmFileName_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : FsmFileName.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : FsmFileName.entry()");

    }


    private void ParserMap_Start_HEADER_FILE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Start.HEADER_FILE(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Start.HEADER_FILE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_HeaderFile_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : HeaderFile.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : HeaderFile.entry()");

    }


    private void ParserMap_Start_IMPORT(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Start.IMPORT(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Start.IMPORT(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Import_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Import.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Import.entry()");

    }


    private void ParserMap_Start_INCLUDE_FILE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Start.INCLUDE_FILE(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Start.INCLUDE_FILE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_IncludeFile_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : IncludeFile.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : IncludeFile.entry()");

    }


    private void ParserMap_Start_MAP_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.isValidHeader())
        {
            debugOutput("LEAVING STATE   : ParserMap.Start");

            debugOutput("BEFORE EXIT     : Start.exit()");

            exitState();

            debugOutput("AFTER EXIT      : Start.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.Start.MAP_NAME(SmcLexer.Token token)");

                clearState();
                ctxt.setHeaderLine(token.getLineNumber());

                debugOutput("EXIT TRANSITION : ParserMap.Start.MAP_NAME(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParserMap_MapName_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : MapName.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : MapName.entry()");
        }
        else
        {
            debugOutput("LEAVING STATE   : ParserMap.Start");

            debugOutput("BEFORE EXIT     : Start.exit()");

            exitState();

            debugOutput("AFTER EXIT      : Start.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.Start.MAP_NAME(SmcLexer.Token token)");

                clearState();
                ctxt.error("%map not preceded by %start and %class.", token.getLineNumber());
                ctxt.setHeaderLine(token.getLineNumber());

                debugOutput("EXIT TRANSITION : ParserMap.Start.MAP_NAME(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParserMap_StartError_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : StartError.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : StartError.entry()");
        }
    }


    private void ParserMap_Start_PACKAGE_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Start.PACKAGE_NAME(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.Start.PACKAGE_NAME(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Package_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Package.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Package.entry()");

    }


    private void ParserMap_Start_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Start.SOURCE(SmcLexer.Token token)");

            clearState();
            ctxt.setSource(token.getValue());
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Start.SOURCE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[stateId]);
        }


    }


    private void ParserMap_Start_START_STATE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Start.START_STATE(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Start.START_STATE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_StartState_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StartState.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StartState.entry()");

    }


    //
    // end of ParserMap.Start State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Context State Transitions.
    //

    private void ParserMap_Context_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Context");

        debugOutput("BEFORE EXIT     : Context.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Context.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Context.Default()");

            clearState();
            ctxt.error("Missing name after %class.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Context.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_StartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StartError.entry()");

    }


    private void ParserMap_Context_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Context");

        debugOutput("BEFORE EXIT     : Context.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Context.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Context.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.setContext(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.Context.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Start.entry()");

    }


    //
    // end of ParserMap.Context State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.StartState State Transitions.
    //

    private void ParserMap_StartState_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.StartState");

        debugOutput("BEFORE EXIT     : StartState.exit()");

        exitState();

        debugOutput("AFTER EXIT      : StartState.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.StartState.Default()");

            clearState();
            ctxt.error("Missing state after %start.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.StartState.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_StartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StartError.entry()");

    }


    private void ParserMap_StartState_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.isValidStartState(token.getValue()))
        {
            debugOutput("LEAVING STATE   : ParserMap.StartState");

            debugOutput("BEFORE EXIT     : StartState.exit()");

            exitState();

            debugOutput("AFTER EXIT      : StartState.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.StartState.WORD(SmcLexer.Token token)");

                clearState();
                ctxt.setStartState(token.getValue());

                debugOutput("EXIT TRANSITION : ParserMap.StartState.WORD(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParserMap_Start_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : Start.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : Start.entry()");
        }
        else
        {
            debugOutput("LEAVING STATE   : ParserMap.StartState");

            debugOutput("BEFORE EXIT     : StartState.exit()");

            exitState();

            debugOutput("AFTER EXIT      : StartState.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.StartState.WORD(SmcLexer.Token token)");

                clearState();
                ctxt.error("Start state must be of the form \"map::state\".", token.getLineNumber());

                debugOutput("EXIT TRANSITION : ParserMap.StartState.WORD(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParserMap_StartError_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : StartError.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : StartError.entry()");
        }
    }


    //
    // end of ParserMap.StartState State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.HeaderFile State Entry/Exit Actions.
    //

    private void ParserMap_HeaderFile__Entry_()
    {
        ctxt.setRawMode("\n\r\f");
    }

    private void ParserMap_HeaderFile__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParserMap.HeaderFile State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.HeaderFile State Transitions.
    //

    private void ParserMap_HeaderFile_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.HeaderFile");

        debugOutput("BEFORE EXIT     : HeaderFile.exit()");

        exitState();

        debugOutput("AFTER EXIT      : HeaderFile.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.HeaderFile.Default()");

            clearState();
            ctxt.error("Missing header file after %header.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.HeaderFile.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_StartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StartError.entry()");

    }


    private void ParserMap_HeaderFile_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.HeaderFile");

        debugOutput("BEFORE EXIT     : HeaderFile.exit()");

        exitState();

        debugOutput("AFTER EXIT      : HeaderFile.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.HeaderFile.SOURCE(SmcLexer.Token token)");

            clearState();
            ctxt.setHeader(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.HeaderFile.SOURCE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Start.entry()");

    }


    //
    // end of ParserMap.HeaderFile State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.IncludeFile State Entry/Exit Actions.
    //

    private void ParserMap_IncludeFile__Entry_()
    {
        ctxt.setRawMode("\n\r\f");
    }

    private void ParserMap_IncludeFile__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParserMap.IncludeFile State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.IncludeFile State Transitions.
    //

    private void ParserMap_IncludeFile_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.IncludeFile");

        debugOutput("BEFORE EXIT     : IncludeFile.exit()");

        exitState();

        debugOutput("AFTER EXIT      : IncludeFile.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.IncludeFile.Default()");

            clearState();
            ctxt.error("Missing include file after %include.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.IncludeFile.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_StartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StartError.entry()");

    }


    private void ParserMap_IncludeFile_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.IncludeFile");

        debugOutput("BEFORE EXIT     : IncludeFile.exit()");

        exitState();

        debugOutput("AFTER EXIT      : IncludeFile.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.IncludeFile.SOURCE(SmcLexer.Token token)");

            clearState();
            ctxt.addInclude(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.IncludeFile.SOURCE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Start.entry()");

    }


    //
    // end of ParserMap.IncludeFile State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Package State Transitions.
    //

    private void ParserMap_Package_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Package");

        debugOutput("BEFORE EXIT     : Package.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Package.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Package.Default()");

            clearState();
            ctxt.error("Missing name after %package.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Package.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_StartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StartError.entry()");

    }


    private void ParserMap_Package_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Package");

        debugOutput("BEFORE EXIT     : Package.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Package.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Package.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.setPackageName(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.Package.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Start.entry()");

    }


    //
    // end of ParserMap.Package State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.FsmClassName State Transitions.
    //

    private void ParserMap_FsmClassName_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.FsmClassName");

        debugOutput("BEFORE EXIT     : FsmClassName.exit()");

        exitState();

        debugOutput("AFTER EXIT      : FsmClassName.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.FsmClassName.Default()");

            clearState();
            ctxt.error("Missing name after %FsmClassName.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.FsmClassName.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_StartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StartError.entry()");

    }


    private void ParserMap_FsmClassName_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.FsmClassName");

        debugOutput("BEFORE EXIT     : FsmClassName.exit()");

        exitState();

        debugOutput("AFTER EXIT      : FsmClassName.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.FsmClassName.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.setFsmClassName(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.FsmClassName.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Start.entry()");

    }


    //
    // end of ParserMap.FsmClassName State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.FsmFileName State Transitions.
    //

    private void ParserMap_FsmFileName_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.FsmFileName");

        debugOutput("BEFORE EXIT     : FsmFileName.exit()");

        exitState();

        debugOutput("AFTER EXIT      : FsmFileName.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.FsmFileName.Default()");

            clearState();
            ctxt.error("Missing name after %FsmClassName.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.FsmFileName.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_StartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StartError.entry()");

    }


    private void ParserMap_FsmFileName_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.FsmFileName");

        debugOutput("BEFORE EXIT     : FsmFileName.exit()");

        exitState();

        debugOutput("AFTER EXIT      : FsmFileName.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.FsmFileName.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.setFsmFileName(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.FsmFileName.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Start.entry()");

    }


    //
    // end of ParserMap.FsmFileName State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Import State Entry/Exit Actions.
    //

    private void ParserMap_Import__Entry_()
    {
        ctxt.setRawMode("\n\r\f");
    }

    private void ParserMap_Import__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParserMap.Import State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Import State Transitions.
    //

    private void ParserMap_Import_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Import");

        debugOutput("BEFORE EXIT     : Import.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Import.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Import.Default()");

            clearState();
            ctxt.error("Missing name after %import.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Import.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_StartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StartError.entry()");

    }


    private void ParserMap_Import_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Import");

        debugOutput("BEFORE EXIT     : Import.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Import.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Import.SOURCE(SmcLexer.Token token)");

            clearState();
            ctxt.addImport(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.Import.SOURCE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Start.entry()");

    }


    //
    // end of ParserMap.Import State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Declare State Entry/Exit Actions.
    //

    private void ParserMap_Declare__Entry_()
    {
        ctxt.setRawMode("\n\r\f");
    }

    private void ParserMap_Declare__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParserMap.Declare State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Declare State Transitions.
    //

    private void ParserMap_Declare_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Declare");

        debugOutput("BEFORE EXIT     : Declare.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Declare.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Declare.Default()");

            clearState();
            ctxt.error("Missing name after %declare.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Declare.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_StartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StartError.entry()");

    }


    private void ParserMap_Declare_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Declare");

        debugOutput("BEFORE EXIT     : Declare.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Declare.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Declare.SOURCE(SmcLexer.Token token)");

            clearState();
            ctxt.addDeclare(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.Declare.SOURCE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Start.entry()");

    }


    //
    // end of ParserMap.Declare State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Access State Entry/Exit Actions.
    //

    private void ParserMap_Access__Entry_()
    {
        ctxt.setRawMode("\n\r\f");
    }

    private void ParserMap_Access__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParserMap.Access State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Access State Transitions.
    //

    private void ParserMap_Access_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Access");

        debugOutput("BEFORE EXIT     : Access.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Access.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Access.Default()");

            clearState();
            ctxt.error("Missing access level after %access.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Access.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_StartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StartError.entry()");

    }


    private void ParserMap_Access_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Access");

        debugOutput("BEFORE EXIT     : Access.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Access.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Access.SOURCE(SmcLexer.Token token)");

            clearState();
            ctxt.setAccessLevel(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.Access.SOURCE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Start.entry()");

    }


    //
    // end of ParserMap.Access State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.StartError State Transitions.
    //

    private void ParserMap_StartError_ACCESS(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.StartError");

        debugOutput("BEFORE EXIT     : StartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : StartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.StartError.ACCESS(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.StartError.ACCESS(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Access_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Access.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Access.entry()");

    }


    private void ParserMap_StartError_CLASS_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.StartError");

        debugOutput("BEFORE EXIT     : StartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : StartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.StartError.CLASS_NAME(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.StartError.CLASS_NAME(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Context_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Context.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Context.entry()");

    }


    private void ParserMap_StartError_DECLARE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.StartError");

        debugOutput("BEFORE EXIT     : StartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : StartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.StartError.DECLARE(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.StartError.DECLARE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Declare_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Declare.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Declare.entry()");

    }


    private void ParserMap_StartError_Default()
    {
        final int stateId = mState.getId();


    }


    private void ParserMap_StartError_FSM_CLASS_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.StartError");

        debugOutput("BEFORE EXIT     : StartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : StartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.StartError.FSM_CLASS_NAME(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.StartError.FSM_CLASS_NAME(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_FsmClassName_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : FsmClassName.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : FsmClassName.entry()");

    }


    private void ParserMap_StartError_FSM_FILE_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.StartError");

        debugOutput("BEFORE EXIT     : StartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : StartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.StartError.FSM_FILE_NAME(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.StartError.FSM_FILE_NAME(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_FsmFileName_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : FsmFileName.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : FsmFileName.entry()");

    }


    private void ParserMap_StartError_HEADER_FILE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.StartError");

        debugOutput("BEFORE EXIT     : StartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : StartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.StartError.HEADER_FILE(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.StartError.HEADER_FILE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_HeaderFile_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : HeaderFile.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : HeaderFile.entry()");

    }


    private void ParserMap_StartError_IMPORT(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.StartError");

        debugOutput("BEFORE EXIT     : StartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : StartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.StartError.IMPORT(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.StartError.IMPORT(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Import_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Import.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Import.entry()");

    }


    private void ParserMap_StartError_MAP_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.isValidHeader())
        {
            debugOutput("LEAVING STATE   : ParserMap.StartError");

            debugOutput("BEFORE EXIT     : StartError.exit()");

            exitState();

            debugOutput("AFTER EXIT      : StartError.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.StartError.MAP_NAME(SmcLexer.Token token)");

                clearState();
                ctxt.setHeaderLine(token.getLineNumber());

                debugOutput("EXIT TRANSITION : ParserMap.StartError.MAP_NAME(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParserMap_MapName_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : MapName.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : MapName.entry()");
        }
        else
        {
            debugOutput("LEAVING STATE   : ParserMap.StartError");

            debugOutput("BEFORE EXIT     : StartError.exit()");

            exitState();

            debugOutput("AFTER EXIT      : StartError.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.StartError.MAP_NAME(SmcLexer.Token token)");

                clearState();
                ctxt.error("%map not preceded by %start and %class.", token.getLineNumber());

                debugOutput("EXIT TRANSITION : ParserMap.StartError.MAP_NAME(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParserMap_StartError_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : StartError.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : StartError.entry()");
        }
    }


    private void ParserMap_StartError_PACKAGE_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.StartError");

        debugOutput("BEFORE EXIT     : StartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : StartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.StartError.PACKAGE_NAME(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.StartError.PACKAGE_NAME(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Package_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Package.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Package.entry()");

    }


    private void ParserMap_StartError_START_STATE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.StartError");

        debugOutput("BEFORE EXIT     : StartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : StartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.StartError.START_STATE(SmcLexer.Token token)");

            clearState();
            ctxt.setHeaderLine(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.StartError.START_STATE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_StartState_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StartState.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StartState.entry()");

    }


    //
    // end of ParserMap.StartError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.MapStart State Transitions.
    //

    private void ParserMap_MapStart_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.MapStart");

        debugOutput("BEFORE EXIT     : MapStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : MapStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.MapStart.Default()");

            clearState();
            ctxt.error("Expecting %map.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.MapStart.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_MapStartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : MapStartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : MapStartError.entry()");

    }


    private void ParserMap_MapStart_MAP_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.MapStart");

        debugOutput("BEFORE EXIT     : MapStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : MapStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.MapStart.MAP_NAME(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.MapStart.MAP_NAME(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_MapName_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : MapName.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : MapName.entry()");

    }


    //
    // end of ParserMap.MapStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.MapStartError State Transitions.
    //

    private void ParserMap_MapStartError_Default()
    {
        final int stateId = mState.getId();


    }


    private void ParserMap_MapStartError_MAP_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.MapStartError");

        debugOutput("BEFORE EXIT     : MapStartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : MapStartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.MapStartError.MAP_NAME(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.MapStartError.MAP_NAME(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_MapName_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : MapName.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : MapName.entry()");

    }


    //
    // end of ParserMap.MapStartError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.MapName State Transitions.
    //

    private void ParserMap_MapName_Default()
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.MapName.Default()");

            clearState();
            ctxt.error("Name expected after \"%map\".", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.MapName.Default()");
        }
        finally
        {
            setState(sStates[stateId]);
        }


    }


    private void ParserMap_MapName_EOD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.MapName");

        debugOutput("BEFORE EXIT     : MapName.exit()");

        exitState();

        debugOutput("AFTER EXIT      : MapName.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.MapName.EOD(SmcLexer.Token token)");

            clearState();
            ctxt.error("Name expected after \"%map\".", token.getLineNumber());
            ctxt.createMap(token.getValue(), token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.MapName.EOD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_States_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : States.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : States.entry()");

    }


    private void ParserMap_MapName_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.isDuplicateMap(token.getValue()))
        {
            debugOutput("LEAVING STATE   : ParserMap.MapName");

            debugOutput("BEFORE EXIT     : MapName.exit()");

            exitState();

            debugOutput("AFTER EXIT      : MapName.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.MapName.WORD(SmcLexer.Token token)");

                clearState();
                ctxt.error("Duplicate map name.", token.getLineNumber());
                ctxt.createMap(token.getValue(), token.getLineNumber());

                debugOutput("EXIT TRANSITION : ParserMap.MapName.WORD(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParserMap_MapStates_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : MapStates.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : MapStates.entry()");
        }
        else
        {
            debugOutput("LEAVING STATE   : ParserMap.MapName");

            debugOutput("BEFORE EXIT     : MapName.exit()");

            exitState();

            debugOutput("AFTER EXIT      : MapName.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.MapName.WORD(SmcLexer.Token token)");

                clearState();
                ctxt.createMap(token.getValue(), token.getLineNumber());

                debugOutput("EXIT TRANSITION : ParserMap.MapName.WORD(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParserMap_MapStates_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : MapStates.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : MapStates.entry()");
        }
    }


    //
    // end of ParserMap.MapName State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.MapStates State Transitions.
    //

    private void ParserMap_MapStates_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.MapStates");

        debugOutput("BEFORE EXIT     : MapStates.exit()");

        exitState();

        debugOutput("AFTER EXIT      : MapStates.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.MapStates.Default()");

            clearState();
            ctxt.error("Expecting %% after \"%map mapname\".", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.MapStates.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_MapStatesError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : MapStatesError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : MapStatesError.entry()");

    }


    private void ParserMap_MapStates_EOD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.MapStates");

        debugOutput("BEFORE EXIT     : MapStates.exit()");

        exitState();

        debugOutput("AFTER EXIT      : MapStates.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.MapStates.EOD(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.MapStates.EOD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_States_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : States.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : States.entry()");

    }


    private void ParserMap_MapStates_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.MapStates");

        debugOutput("BEFORE EXIT     : MapStates.exit()");

        exitState();

        debugOutput("AFTER EXIT      : MapStates.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.MapStates.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.error("Expecting %% after \"%map mapname\".", token.getLineNumber());
            ctxt.createState(token.getValue(), token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.MapStates.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_StateStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StateStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StateStart.entry()");

    }


    //
    // end of ParserMap.MapStates State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.MapStatesError State Transitions.
    //

    private void ParserMap_MapStatesError_Default()
    {
        final int stateId = mState.getId();


    }


    private void ParserMap_MapStatesError_EOD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.MapStatesError");

        debugOutput("BEFORE EXIT     : MapStatesError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : MapStatesError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.MapStatesError.EOD(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.MapStatesError.EOD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_States_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : States.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : States.entry()");

    }


    private void ParserMap_MapStatesError_MAP_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.MapStatesError");

        debugOutput("BEFORE EXIT     : MapStatesError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : MapStatesError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.MapStatesError.MAP_NAME(SmcLexer.Token token)");

            clearState();
            ctxt.addMap();

            debugOutput("EXIT TRANSITION : ParserMap.MapStatesError.MAP_NAME(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_MapName_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : MapName.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : MapName.entry()");

    }


    private void ParserMap_MapStatesError_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.MapStatesError");

        debugOutput("BEFORE EXIT     : MapStatesError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : MapStatesError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.MapStatesError.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.createState(token.getValue(), token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.MapStatesError.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_StateStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StateStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StateStart.entry()");

    }


    //
    // end of ParserMap.MapStatesError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.States State Transitions.
    //

    private void ParserMap_States_Default()
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.States.Default()");

            clearState();
            ctxt.error("Expecting either a new state definition or end of map (%%).", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.States.Default()");
        }
        finally
        {
            setState(sStates[stateId]);
        }


    }


    private void ParserMap_States_ENTRY(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.States");

        debugOutput("BEFORE EXIT     : States.exit()");

        exitState();

        debugOutput("AFTER EXIT      : States.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.States.ENTRY(SmcLexer.Token token)");

            clearState();
            ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
            ctxt.createState(token.getValue(), token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.States.ENTRY(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_EntryStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : EntryStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : EntryStart.entry()");

    }


    private void ParserMap_States_EOD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.States");

        debugOutput("BEFORE EXIT     : States.exit()");

        exitState();

        debugOutput("AFTER EXIT      : States.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.States.EOD(SmcLexer.Token token)");

            clearState();
            ctxt.addMap();

            debugOutput("EXIT TRANSITION : ParserMap.States.EOD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_MapStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : MapStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : MapStart.entry()");

    }


    private void ParserMap_States_EQUAL(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.States");

        debugOutput("BEFORE EXIT     : States.exit()");

        exitState();

        debugOutput("AFTER EXIT      : States.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.States.EQUAL(SmcLexer.Token token)");

            clearState();
            ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
            ctxt.createState(token.getValue(), token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.States.EQUAL(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Transitions_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Transitions.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Transitions.entry()");

    }


    private void ParserMap_States_EXIT(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.States");

        debugOutput("BEFORE EXIT     : States.exit()");

        exitState();

        debugOutput("AFTER EXIT      : States.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.States.EXIT(SmcLexer.Token token)");

            clearState();
            ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
            ctxt.createState(token.getValue(), token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.States.EXIT(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ExitStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ExitStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ExitStart.entry()");

    }


    private void ParserMap_States_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.States");

        debugOutput("BEFORE EXIT     : States.exit()");

        exitState();

        debugOutput("AFTER EXIT      : States.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.States.LEFT_BRACE(SmcLexer.Token token)");

            clearState();
            ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
            ctxt.createState(token.getValue(), token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.States.LEFT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Transitions_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Transitions.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Transitions.entry()");

    }


    private void ParserMap_States_MAP_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.States");

        debugOutput("BEFORE EXIT     : States.exit()");

        exitState();

        debugOutput("AFTER EXIT      : States.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.States.MAP_NAME(SmcLexer.Token token)");

            clearState();
            ctxt.error("Expecting \"%%\" before another \"%map\".", token.getLineNumber());
            ctxt.addMap();

            debugOutput("EXIT TRANSITION : ParserMap.States.MAP_NAME(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_MapName_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : MapName.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : MapName.entry()");

    }


    private void ParserMap_States_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.isDuplicateState(token.getValue()))
        {
            debugOutput("LEAVING STATE   : ParserMap.States");

            debugOutput("BEFORE EXIT     : States.exit()");

            exitState();

            debugOutput("AFTER EXIT      : States.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.States.WORD(SmcLexer.Token token)");

                clearState();
                ctxt.error("Duplicate state name.", token.getLineNumber());
                ctxt.createState(token.getValue(), token.getLineNumber());

                debugOutput("EXIT TRANSITION : ParserMap.States.WORD(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParserMap_StateStart_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : StateStart.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : StateStart.entry()");
        }
        else
        {
            debugOutput("LEAVING STATE   : ParserMap.States");

            debugOutput("BEFORE EXIT     : States.exit()");

            exitState();

            debugOutput("AFTER EXIT      : States.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.States.WORD(SmcLexer.Token token)");

                clearState();
                ctxt.createState(token.getValue(), token.getLineNumber());

                debugOutput("EXIT TRANSITION : ParserMap.States.WORD(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParserMap_StateStart_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : StateStart.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : StateStart.entry()");
        }
    }


    //
    // end of ParserMap.States State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.StateStart State Transitions.
    //

    private void ParserMap_StateStart_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.StateStart");

        debugOutput("BEFORE EXIT     : StateStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : StateStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.StateStart.Default()");

            clearState();
            ctxt.error("After the state name is given, then either an entry action, exit action or opening brace is expected.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.StateStart.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_StateStartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StateStartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StateStartError.entry()");

    }


    private void ParserMap_StateStart_ENTRY(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.isDefaultState())
        {
            debugOutput("LEAVING STATE   : ParserMap.StateStart");

            debugOutput("BEFORE EXIT     : StateStart.exit()");

            exitState();

            debugOutput("AFTER EXIT      : StateStart.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.StateStart.ENTRY(SmcLexer.Token token)");

                clearState();
                ctxt.error("Default state may not have an entry action.", token.getLineNumber());

                debugOutput("EXIT TRANSITION : ParserMap.StateStart.ENTRY(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParserMap_EntryStart_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : EntryStart.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : EntryStart.entry()");
        }
        else
        {
            debugOutput("LEAVING STATE   : ParserMap.StateStart");

            debugOutput("BEFORE EXIT     : StateStart.exit()");

            exitState();

            debugOutput("AFTER EXIT      : StateStart.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.StateStart.ENTRY(SmcLexer.Token token)");


                debugOutput("EXIT TRANSITION : ParserMap.StateStart.ENTRY(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParserMap_EntryStart_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : EntryStart.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : EntryStart.entry()");
        }
    }


    private void ParserMap_StateStart_EXIT(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.isDefaultState())
        {
            debugOutput("LEAVING STATE   : ParserMap.StateStart");

            debugOutput("BEFORE EXIT     : StateStart.exit()");

            exitState();

            debugOutput("AFTER EXIT      : StateStart.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.StateStart.EXIT(SmcLexer.Token token)");

                clearState();
                ctxt.error("Default state may not have an exit action.", token.getLineNumber());

                debugOutput("EXIT TRANSITION : ParserMap.StateStart.EXIT(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParserMap_ExitStart_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : ExitStart.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : ExitStart.entry()");
        }
        else
        {
            debugOutput("LEAVING STATE   : ParserMap.StateStart");

            debugOutput("BEFORE EXIT     : StateStart.exit()");

            exitState();

            debugOutput("AFTER EXIT      : StateStart.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.StateStart.EXIT(SmcLexer.Token token)");


                debugOutput("EXIT TRANSITION : ParserMap.StateStart.EXIT(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParserMap_ExitStart_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : ExitStart.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : ExitStart.entry()");
        }
    }


    private void ParserMap_StateStart_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.StateStart");

        debugOutput("BEFORE EXIT     : StateStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : StateStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.StateStart.LEFT_BRACE(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.StateStart.LEFT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Transitions_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Transitions.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Transitions.entry()");

    }


    //
    // end of ParserMap.StateStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.StateStartError State Transitions.
    //

    private void ParserMap_StateStartError_Default()
    {
        final int stateId = mState.getId();


    }


    private void ParserMap_StateStartError_ENTRY(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.StateStartError");

        debugOutput("BEFORE EXIT     : StateStartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : StateStartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.StateStartError.ENTRY(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.StateStartError.ENTRY(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_EntryStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : EntryStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : EntryStart.entry()");

    }


    private void ParserMap_StateStartError_EXIT(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.StateStartError");

        debugOutput("BEFORE EXIT     : StateStartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : StateStartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.StateStartError.EXIT(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.StateStartError.EXIT(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ExitStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ExitStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ExitStart.entry()");

    }


    private void ParserMap_StateStartError_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.StateStartError");

        debugOutput("BEFORE EXIT     : StateStartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : StateStartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.StateStartError.LEFT_BRACE(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.StateStartError.LEFT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Transitions_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Transitions.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Transitions.entry()");

    }


    //
    // end of ParserMap.StateStartError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.EntryStart State Transitions.
    //

    private void ParserMap_EntryStart_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.EntryStart");

        debugOutput("BEFORE EXIT     : EntryStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : EntryStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.EntryStart.Default()");

            clearState();
            ctxt.error("An opening brace is expected after Entry.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.EntryStart.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_StateStartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StateStartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StateStartError.entry()");

    }


    private void ParserMap_EntryStart_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.EntryStart.LEFT_BRACE(SmcLexer.Token token)");

            clearState();
            ctxt.createActionList();

            debugOutput("EXIT TRANSITION : ParserMap.EntryStart.LEFT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_EntryEnd_STATE_ID]);
            enterState();
            pushState(sStates[ActionMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionMap::Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionMap::Start.entry()");

    }


    //
    // end of ParserMap.EntryStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.EntryEnd State Transitions.
    //

    private void ParserMap_EntryEnd_actionsDone(List<SmcAction> actions, int lineNumber)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.EntryEnd");

        debugOutput("BEFORE EXIT     : EntryEnd.exit()");

        exitState();

        debugOutput("AFTER EXIT      : EntryEnd.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.EntryEnd.actionsDone(List<SmcAction> actions, int lineNumber)");

            clearState();
            ctxt.setEntryAction(actions);

            debugOutput("EXIT TRANSITION : ParserMap.EntryEnd.actionsDone(List<SmcAction> actions, int lineNumber)");
        }
        finally
        {
            setState(sStates[ParserMap_StateStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StateStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StateStart.entry()");

    }


    private void ParserMap_EntryEnd_actionsError()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.EntryEnd");

        debugOutput("BEFORE EXIT     : EntryEnd.exit()");

        exitState();

        debugOutput("AFTER EXIT      : EntryEnd.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.EntryEnd.actionsError()");


            debugOutput("EXIT TRANSITION : ParserMap.EntryEnd.actionsError()");
        }
        finally
        {
            setState(sStates[ParserMap_StartState_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StartState.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StartState.entry()");

    }


    //
    // end of ParserMap.EntryEnd State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.ExitStart State Transitions.
    //

    private void ParserMap_ExitStart_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.ExitStart");

        debugOutput("BEFORE EXIT     : ExitStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : ExitStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.ExitStart.Default()");

            clearState();
            ctxt.error("A opening brace is expected after Exit.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.ExitStart.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_StateStartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StateStartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StateStartError.entry()");

    }


    private void ParserMap_ExitStart_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.ExitStart.LEFT_BRACE(SmcLexer.Token token)");

            clearState();
            ctxt.createActionList();

            debugOutput("EXIT TRANSITION : ParserMap.ExitStart.LEFT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ExitEnd_STATE_ID]);
            enterState();
            pushState(sStates[ActionMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionMap::Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionMap::Start.entry()");

    }


    //
    // end of ParserMap.ExitStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.ExitEnd State Transitions.
    //

    private void ParserMap_ExitEnd_actionsDone(List<SmcAction> actions, int lineNumber)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.ExitEnd");

        debugOutput("BEFORE EXIT     : ExitEnd.exit()");

        exitState();

        debugOutput("AFTER EXIT      : ExitEnd.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.ExitEnd.actionsDone(List<SmcAction> actions, int lineNumber)");

            clearState();
            ctxt.setExitAction(actions);

            debugOutput("EXIT TRANSITION : ParserMap.ExitEnd.actionsDone(List<SmcAction> actions, int lineNumber)");
        }
        finally
        {
            setState(sStates[ParserMap_StateStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StateStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StateStart.entry()");

    }


    private void ParserMap_ExitEnd_actionsError()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.ExitEnd");

        debugOutput("BEFORE EXIT     : ExitEnd.exit()");

        exitState();

        debugOutput("AFTER EXIT      : ExitEnd.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.ExitEnd.actionsError()");


            debugOutput("EXIT TRANSITION : ParserMap.ExitEnd.actionsError()");
        }
        finally
        {
            setState(sStates[ParserMap_StateStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : StateStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : StateStart.entry()");

    }


    //
    // end of ParserMap.ExitEnd State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Transitions State Transitions.
    //

    private void ParserMap_Transitions_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Transitions");

        debugOutput("BEFORE EXIT     : Transitions.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Transitions.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Transitions.Default()");

            clearState();
            ctxt.error("Expecting either a new transition or a closing brace.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.Transitions.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_TransError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : TransError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : TransError.entry()");

    }


    private void ParserMap_Transitions_RIGHT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Transitions");

        debugOutput("BEFORE EXIT     : Transitions.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Transitions.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Transitions.RIGHT_BRACE(SmcLexer.Token token)");

            clearState();
            ctxt.addState();

            debugOutput("EXIT TRANSITION : ParserMap.Transitions.RIGHT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_States_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : States.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : States.entry()");

    }


    private void ParserMap_Transitions_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.Transitions");

        debugOutput("BEFORE EXIT     : Transitions.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Transitions.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.Transitions.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.storeTransitionName(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.Transitions.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_TransStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : TransStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : TransStart.entry()");

    }


    //
    // end of ParserMap.Transitions State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransError State Transitions.
    //

    private void ParserMap_TransError_Default()
    {
        final int stateId = mState.getId();


    }


    private void ParserMap_TransError_RIGHT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransError");

        debugOutput("BEFORE EXIT     : TransError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransError.RIGHT_BRACE(SmcLexer.Token token)");

            clearState();
            ctxt.addState();

            debugOutput("EXIT TRANSITION : ParserMap.TransError.RIGHT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_States_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : States.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : States.entry()");

    }


    private void ParserMap_TransError_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransError");

        debugOutput("BEFORE EXIT     : TransError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransError.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.storeTransitionName(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.TransError.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_TransStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : TransStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : TransStart.entry()");

    }


    //
    // end of ParserMap.TransError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransStart State Transitions.
    //

    private void ParserMap_TransStart_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransStart");

        debugOutput("BEFORE EXIT     : TransStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransStart.Default()");

            clearState();
            ctxt.error("Expecting either a guard, \"push\", \"pop\", \"jump\" or end state.", ctxt.getLineNumber());
            ctxt.createTransition(ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.TransStart.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_TransStartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : TransStartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : TransStartError.entry()");

    }


    private void ParserMap_TransStart_JUMP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransStart");

        debugOutput("BEFORE EXIT     : TransStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransStart.JUMP(SmcLexer.Token token)");

            clearState();
            ctxt.createTransition(token.getLineNumber());
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);

            debugOutput("EXIT TRANSITION : ParserMap.TransStart.JUMP(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_JumpStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : JumpStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : JumpStart.entry()");

    }


    private void ParserMap_TransStart_LEFT_BRACKET(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransStart");

        debugOutput("BEFORE EXIT     : TransStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransStart.LEFT_BRACKET(SmcLexer.Token token)");

            clearState();
            ctxt.createTransition(token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.TransStart.LEFT_BRACKET(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_TransGuard_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : TransGuard.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : TransGuard.entry()");

    }


    private void ParserMap_TransStart_LEFT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransStart.LEFT_PAREN(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.TransStart.LEFT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_TransParams_STATE_ID]);
            enterState();
            pushState(sStates[ParamMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ParamMap::Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ParamMap::Start.entry()");

    }


    private void ParserMap_TransStart_POP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransStart");

        debugOutput("BEFORE EXIT     : TransStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransStart.POP(SmcLexer.Token token)");

            clearState();
            ctxt.createTransition(token.getLineNumber());
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_POP);

            debugOutput("EXIT TRANSITION : ParserMap.TransStart.POP(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PopStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PopStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PopStart.entry()");

    }


    private void ParserMap_TransStart_PUSH(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransStart");

        debugOutput("BEFORE EXIT     : TransStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransStart.PUSH(SmcLexer.Token token)");

            clearState();
            ctxt.createTransition(token.getLineNumber());
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_PUSH);
            ctxt.setEndState("nil");

            debugOutput("EXIT TRANSITION : ParserMap.TransStart.PUSH(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PushStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PushStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PushStart.entry()");

    }


    private void ParserMap_TransStart_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransStart");

        debugOutput("BEFORE EXIT     : TransStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransStart.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.createTransition(token.getLineNumber());
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.TransStart.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_SimpleTrans_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : SimpleTrans.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : SimpleTrans.entry()");

    }


    //
    // end of ParserMap.TransStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransStartError State Transitions.
    //

    private void ParserMap_TransStartError_Default()
    {
        final int stateId = mState.getId();


    }


    private void ParserMap_TransStartError_JUMP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransStartError");

        debugOutput("BEFORE EXIT     : TransStartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransStartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransStartError.JUMP(SmcLexer.Token token)");

            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState("nil");

            debugOutput("EXIT TRANSITION : ParserMap.TransStartError.JUMP(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_JumpStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : JumpStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : JumpStart.entry()");

    }


    private void ParserMap_TransStartError_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransStartError.LEFT_BRACE(SmcLexer.Token token)");

            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState("End state missing");
            ctxt.createActionList();

            debugOutput("EXIT TRANSITION : ParserMap.TransStartError.LEFT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(sStates[ActionMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionMap::Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionMap::Start.entry()");

    }


    private void ParserMap_TransStartError_LEFT_BRACKET(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransStartError");

        debugOutput("BEFORE EXIT     : TransStartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransStartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransStartError.LEFT_BRACKET(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.TransStartError.LEFT_BRACKET(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_TransGuard_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : TransGuard.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : TransGuard.entry()");

    }


    private void ParserMap_TransStartError_LEFT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransStartError.LEFT_PAREN(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.TransStartError.LEFT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_TransParams_STATE_ID]);
            enterState();
            pushState(sStates[ParamMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ParamMap::Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ParamMap::Start.entry()");

    }


    private void ParserMap_TransStartError_POP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransStartError");

        debugOutput("BEFORE EXIT     : TransStartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransStartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransStartError.POP(SmcLexer.Token token)");

            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_POP);

            debugOutput("EXIT TRANSITION : ParserMap.TransStartError.POP(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PopStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PopStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PopStart.entry()");

    }


    private void ParserMap_TransStartError_PUSH(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransStartError");

        debugOutput("BEFORE EXIT     : TransStartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransStartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransStartError.PUSH(SmcLexer.Token token)");

            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_PUSH);
            ctxt.setEndState("nil");

            debugOutput("EXIT TRANSITION : ParserMap.TransStartError.PUSH(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PushStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PushStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PushStart.entry()");

    }


    private void ParserMap_TransStartError_RIGHT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransStartError");

        debugOutput("BEFORE EXIT     : TransStartError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransStartError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransStartError.RIGHT_BRACE(SmcLexer.Token token)");

            clearState();
            ctxt.addGuard();
            ctxt.addTransition();

            debugOutput("EXIT TRANSITION : ParserMap.TransStartError.RIGHT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_Transitions_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Transitions.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Transitions.entry()");

    }


    //
    // end of ParserMap.TransStartError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransParams State Transitions.
    //

    private void ParserMap_TransParams_paramsDone(List<SmcParameter> params, int lineNumber)
    {
        final int stateId = mState.getId();

        if (ctxt.getTransitionName().equalsIgnoreCase("Default") &&
       !params.isEmpty())
        {
            debugOutput("LEAVING STATE   : ParserMap.TransParams");

            debugOutput("BEFORE EXIT     : TransParams.exit()");

            exitState();

            debugOutput("AFTER EXIT      : TransParams.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.TransParams.paramsDone(List<SmcParameter> params, int lineNumber)");

                clearState();
                ctxt.error("Default transitions may not have parameters.", lineNumber);
                ctxt.createTransition(params, lineNumber);

                debugOutput("EXIT TRANSITION : ParserMap.TransParams.paramsDone(List<SmcParameter> params, int lineNumber)");
            }
            finally
            {
                setState(sStates[ParserMap_TransNext_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : TransNext.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : TransNext.entry()");
        }
        else
        {
            debugOutput("LEAVING STATE   : ParserMap.TransParams");

            debugOutput("BEFORE EXIT     : TransParams.exit()");

            exitState();

            debugOutput("AFTER EXIT      : TransParams.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParserMap.TransParams.paramsDone(List<SmcParameter> params, int lineNumber)");

                clearState();
                ctxt.createTransition(params, lineNumber);

                debugOutput("EXIT TRANSITION : ParserMap.TransParams.paramsDone(List<SmcParameter> params, int lineNumber)");
            }
            finally
            {
                setState(sStates[ParserMap_TransNext_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : TransNext.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : TransNext.entry()");
        }
    }


    private void ParserMap_TransParams_paramsError(List<SmcParameter> params, int lineNumber)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransParams");

        debugOutput("BEFORE EXIT     : TransParams.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransParams.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransParams.paramsError(List<SmcParameter> params, int lineNumber)");

            clearState();
            ctxt.createTransition(params, lineNumber);

            debugOutput("EXIT TRANSITION : ParserMap.TransParams.paramsError(List<SmcParameter> params, int lineNumber)");
        }
        finally
        {
            setState(sStates[ParserMap_TransNext_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : TransNext.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : TransNext.entry()");

    }


    //
    // end of ParserMap.TransParams State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransNext State Transitions.
    //

    private void ParserMap_TransNext_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransNext");

        debugOutput("BEFORE EXIT     : TransNext.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransNext.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransNext.Default()");

            clearState();
            ctxt.error("Expecting either a guard, \"push\", \"pop\", \"jump\" or end state.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.TransNext.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_TransNextError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : TransNextError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : TransNextError.entry()");

    }


    private void ParserMap_TransNext_JUMP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransNext");

        debugOutput("BEFORE EXIT     : TransNext.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransNext.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransNext.JUMP(SmcLexer.Token token)");

            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState("nil");

            debugOutput("EXIT TRANSITION : ParserMap.TransNext.JUMP(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_JumpStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : JumpStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : JumpStart.entry()");

    }


    private void ParserMap_TransNext_LEFT_BRACKET(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransNext");

        debugOutput("BEFORE EXIT     : TransNext.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransNext.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransNext.LEFT_BRACKET(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.TransNext.LEFT_BRACKET(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_TransGuard_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : TransGuard.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : TransGuard.entry()");

    }


    private void ParserMap_TransNext_POP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransNext");

        debugOutput("BEFORE EXIT     : TransNext.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransNext.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransNext.POP(SmcLexer.Token token)");

            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_POP);

            debugOutput("EXIT TRANSITION : ParserMap.TransNext.POP(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PopStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PopStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PopStart.entry()");

    }


    private void ParserMap_TransNext_PUSH(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransNext");

        debugOutput("BEFORE EXIT     : TransNext.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransNext.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransNext.PUSH(SmcLexer.Token token)");

            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_PUSH);
            ctxt.setEndState("nil");

            debugOutput("EXIT TRANSITION : ParserMap.TransNext.PUSH(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PushStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PushStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PushStart.entry()");

    }


    private void ParserMap_TransNext_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransNext");

        debugOutput("BEFORE EXIT     : TransNext.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransNext.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransNext.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.TransNext.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_SimpleTrans_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : SimpleTrans.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : SimpleTrans.entry()");

    }


    //
    // end of ParserMap.TransNext State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransNextError State Transitions.
    //

    private void ParserMap_TransNextError_Default()
    {
        final int stateId = mState.getId();


    }


    private void ParserMap_TransNextError_JUMP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransNextError");

        debugOutput("BEFORE EXIT     : TransNextError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransNextError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransNextError.JUMP(SmcLexer.Token token)");

            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState("nil");

            debugOutput("EXIT TRANSITION : ParserMap.TransNextError.JUMP(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_JumpStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : JumpStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : JumpStart.entry()");

    }


    private void ParserMap_TransNextError_LEFT_BRACKET(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransNextError");

        debugOutput("BEFORE EXIT     : TransNextError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransNextError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransNextError.LEFT_BRACKET(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.TransNextError.LEFT_BRACKET(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_TransGuard_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : TransGuard.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : TransGuard.entry()");

    }


    private void ParserMap_TransNextError_LEFT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();


    }


    private void ParserMap_TransNextError_POP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransNextError");

        debugOutput("BEFORE EXIT     : TransNextError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransNextError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransNextError.POP(SmcLexer.Token token)");

            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_POP);

            debugOutput("EXIT TRANSITION : ParserMap.TransNextError.POP(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PopStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PopStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PopStart.entry()");

    }


    private void ParserMap_TransNextError_PUSH(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransNextError");

        debugOutput("BEFORE EXIT     : TransNextError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransNextError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransNextError.PUSH(SmcLexer.Token token)");

            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_PUSH);
            ctxt.setEndState("nil");

            debugOutput("EXIT TRANSITION : ParserMap.TransNextError.PUSH(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PushStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PushStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PushStart.entry()");

    }


    private void ParserMap_TransNextError_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransNextError");

        debugOutput("BEFORE EXIT     : TransNextError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransNextError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransNextError.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.TransNextError.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_SimpleTrans_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : SimpleTrans.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : SimpleTrans.entry()");

    }


    //
    // end of ParserMap.TransNextError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransGuard State Entry/Exit Actions.
    //

    private void ParserMap_TransGuard__Entry_()
    {
        ctxt.setRawMode("[", "]");
    }

    private void ParserMap_TransGuard__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParserMap.TransGuard State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransGuard State Transitions.
    //

    private void ParserMap_TransGuard_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.TransGuard");

        debugOutput("BEFORE EXIT     : TransGuard.exit()");

        exitState();

        debugOutput("AFTER EXIT      : TransGuard.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.TransGuard.SOURCE(SmcLexer.Token token)");

            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), token.getValue(), token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.TransGuard.SOURCE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_EndState_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : EndState.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : EndState.entry()");

    }


    //
    // end of ParserMap.TransGuard State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.EndState State Transitions.
    //

    private void ParserMap_EndState_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.EndState");

        debugOutput("BEFORE EXIT     : EndState.exit()");

        exitState();

        debugOutput("AFTER EXIT      : EndState.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.EndState.Default()");

            clearState();
            ctxt.error("Expecting either \"push\", \"pop\", \"jump\" or end state.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.EndState.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_EndStateError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : EndStateError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : EndStateError.entry()");

    }


    private void ParserMap_EndState_JUMP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.EndState");

        debugOutput("BEFORE EXIT     : EndState.exit()");

        exitState();

        debugOutput("AFTER EXIT      : EndState.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.EndState.JUMP(SmcLexer.Token token)");

            clearState();
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState("nil");

            debugOutput("EXIT TRANSITION : ParserMap.EndState.JUMP(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_JumpStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : JumpStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : JumpStart.entry()");

    }


    private void ParserMap_EndState_POP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.EndState");

        debugOutput("BEFORE EXIT     : EndState.exit()");

        exitState();

        debugOutput("AFTER EXIT      : EndState.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.EndState.POP(SmcLexer.Token token)");

            clearState();
            ctxt.setTransType(TransType.TRANS_POP);

            debugOutput("EXIT TRANSITION : ParserMap.EndState.POP(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PopStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PopStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PopStart.entry()");

    }


    private void ParserMap_EndState_PUSH(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.EndState");

        debugOutput("BEFORE EXIT     : EndState.exit()");

        exitState();

        debugOutput("AFTER EXIT      : EndState.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.EndState.PUSH(SmcLexer.Token token)");

            clearState();
            ctxt.setTransType(TransType.TRANS_PUSH);
            ctxt.setEndState("nil");

            debugOutput("EXIT TRANSITION : ParserMap.EndState.PUSH(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PushStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PushStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PushStart.entry()");

    }


    private void ParserMap_EndState_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.EndState");

        debugOutput("BEFORE EXIT     : EndState.exit()");

        exitState();

        debugOutput("AFTER EXIT      : EndState.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.EndState.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.EndState.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_SimpleTrans_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : SimpleTrans.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : SimpleTrans.entry()");

    }


    //
    // end of ParserMap.EndState State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.EndStateError State Transitions.
    //

    private void ParserMap_EndStateError_Default()
    {
        final int stateId = mState.getId();


    }


    private void ParserMap_EndStateError_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.EndStateError.LEFT_BRACE(SmcLexer.Token token)");

            clearState();
            ctxt.createActionList();

            debugOutput("EXIT TRANSITION : ParserMap.EndStateError.LEFT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(sStates[ActionMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionMap::Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionMap::Start.entry()");

    }


    //
    // end of ParserMap.EndStateError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.SimpleTrans State Transitions.
    //

    private void ParserMap_SimpleTrans_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.SimpleTrans");

        debugOutput("BEFORE EXIT     : SimpleTrans.exit()");

        exitState();

        debugOutput("AFTER EXIT      : SimpleTrans.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.SimpleTrans.Default()");

            clearState();
            ctxt.error("An opening brace must proceed any action definitions.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.SimpleTrans.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_ActionStartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionStartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionStartError.entry()");

    }


    private void ParserMap_SimpleTrans_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.SimpleTrans.LEFT_BRACE(SmcLexer.Token token)");

            clearState();
            ctxt.createActionList();

            debugOutput("EXIT TRANSITION : ParserMap.SimpleTrans.LEFT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(sStates[ActionMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionMap::Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionMap::Start.entry()");

    }


    private void ParserMap_SimpleTrans_SLASH(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.SimpleTrans");

        debugOutput("BEFORE EXIT     : SimpleTrans.exit()");

        exitState();

        debugOutput("AFTER EXIT      : SimpleTrans.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.SimpleTrans.SLASH(SmcLexer.Token token)");

            clearState();
            ctxt.setTransType(TransType.TRANS_PUSH);

            debugOutput("EXIT TRANSITION : ParserMap.SimpleTrans.SLASH(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PushTransition_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PushTransition.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PushTransition.entry()");

    }


    //
    // end of ParserMap.SimpleTrans State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PushTransition State Transitions.
    //

    private void ParserMap_PushTransition_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PushTransition");

        debugOutput("BEFORE EXIT     : PushTransition.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PushTransition.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PushTransition.Default()");

            clearState();
            ctxt.error("\"push\" must follow a '/'.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.PushTransition.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_PushError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PushError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PushError.entry()");

    }


    private void ParserMap_PushTransition_PUSH(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PushTransition");

        debugOutput("BEFORE EXIT     : PushTransition.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PushTransition.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PushTransition.PUSH(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.PushTransition.PUSH(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PushStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PushStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PushStart.entry()");

    }


    //
    // end of ParserMap.PushTransition State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PushStart State Transitions.
    //

    private void ParserMap_PushStart_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PushStart");

        debugOutput("BEFORE EXIT     : PushStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PushStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PushStart.Default()");

            clearState();
            ctxt.error("\"push\" must be followed by a '/'.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.PushStart.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_PushError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PushError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PushError.entry()");

    }


    private void ParserMap_PushStart_LEFT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PushStart");

        debugOutput("BEFORE EXIT     : PushStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PushStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PushStart.LEFT_PAREN(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.PushStart.LEFT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PushMap_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PushMap.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PushMap.entry()");

    }


    //
    // end of ParserMap.PushStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PushError State Transitions.
    //

    private void ParserMap_PushError_Default()
    {
        final int stateId = mState.getId();


    }


    private void ParserMap_PushError_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PushError.LEFT_BRACE(SmcLexer.Token token)");

            clearState();
            ctxt.createActionList();

            debugOutput("EXIT TRANSITION : ParserMap.PushError.LEFT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(sStates[ActionMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionMap::Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionMap::Start.entry()");

    }


    private void ParserMap_PushError_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PushError");

        debugOutput("BEFORE EXIT     : PushError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PushError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PushError.RIGHT_PAREN(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.PushError.RIGHT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionStart.entry()");

    }


    //
    // end of ParserMap.PushError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PushMap State Transitions.
    //

    private void ParserMap_PushMap_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PushMap");

        debugOutput("BEFORE EXIT     : PushMap.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PushMap.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PushMap.Default()");

            clearState();
            ctxt.error("Expecting a state name.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.PushMap.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_PushError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PushError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PushError.entry()");

    }


    private void ParserMap_PushMap_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PushMap");

        debugOutput("BEFORE EXIT     : PushMap.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PushMap.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PushMap.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.setPushState(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.PushMap.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PushEnd_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PushEnd.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PushEnd.entry()");

    }


    //
    // end of ParserMap.PushMap State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PushEnd State Transitions.
    //

    private void ParserMap_PushEnd_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PushEnd");

        debugOutput("BEFORE EXIT     : PushEnd.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PushEnd.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PushEnd.Default()");

            clearState();
            ctxt.error("push transition missing closing paren.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.PushEnd.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_PushError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PushError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PushError.entry()");

    }


    private void ParserMap_PushEnd_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PushEnd");

        debugOutput("BEFORE EXIT     : PushEnd.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PushEnd.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PushEnd.RIGHT_PAREN(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.PushEnd.RIGHT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionStart.entry()");

    }


    //
    // end of ParserMap.PushEnd State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.JumpStart State Transitions.
    //

    private void ParserMap_JumpStart_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.JumpStart");

        debugOutput("BEFORE EXIT     : JumpStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : JumpStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.JumpStart.Default()");

            clearState();
            ctxt.error("\"jump\" must be followed by a '/'.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.JumpStart.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_JumpError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : JumpError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : JumpError.entry()");

    }


    private void ParserMap_JumpStart_LEFT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.JumpStart");

        debugOutput("BEFORE EXIT     : JumpStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : JumpStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.JumpStart.LEFT_PAREN(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.JumpStart.LEFT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_JumpMap_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : JumpMap.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : JumpMap.entry()");

    }


    //
    // end of ParserMap.JumpStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.JumpError State Transitions.
    //

    private void ParserMap_JumpError_Default()
    {
        final int stateId = mState.getId();


    }


    private void ParserMap_JumpError_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.JumpError.LEFT_BRACE(SmcLexer.Token token)");

            clearState();
            ctxt.createActionList();

            debugOutput("EXIT TRANSITION : ParserMap.JumpError.LEFT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(sStates[ActionMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionMap::Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionMap::Start.entry()");

    }


    private void ParserMap_JumpError_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.JumpError");

        debugOutput("BEFORE EXIT     : JumpError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : JumpError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.JumpError.RIGHT_PAREN(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.JumpError.RIGHT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionStart.entry()");

    }


    //
    // end of ParserMap.JumpError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.JumpMap State Transitions.
    //

    private void ParserMap_JumpMap_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.JumpMap");

        debugOutput("BEFORE EXIT     : JumpMap.exit()");

        exitState();

        debugOutput("AFTER EXIT      : JumpMap.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.JumpMap.Default()");

            clearState();
            ctxt.error("Expecting a state name.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.JumpMap.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_JumpError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : JumpError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : JumpError.entry()");

    }


    private void ParserMap_JumpMap_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.JumpMap");

        debugOutput("BEFORE EXIT     : JumpMap.exit()");

        exitState();

        debugOutput("AFTER EXIT      : JumpMap.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.JumpMap.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.setEndState(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.JumpMap.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_JumpEnd_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : JumpEnd.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : JumpEnd.entry()");

    }


    //
    // end of ParserMap.JumpMap State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.JumpEnd State Transitions.
    //

    private void ParserMap_JumpEnd_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.JumpEnd");

        debugOutput("BEFORE EXIT     : JumpEnd.exit()");

        exitState();

        debugOutput("AFTER EXIT      : JumpEnd.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.JumpEnd.Default()");

            clearState();
            ctxt.error("jump transition missing closing paren.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.JumpEnd.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_JumpError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : JumpError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : JumpError.entry()");

    }


    private void ParserMap_JumpEnd_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.JumpEnd");

        debugOutput("BEFORE EXIT     : JumpEnd.exit()");

        exitState();

        debugOutput("AFTER EXIT      : JumpEnd.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.JumpEnd.RIGHT_PAREN(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.JumpEnd.RIGHT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionStart.entry()");

    }


    //
    // end of ParserMap.JumpEnd State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PopStart State Transitions.
    //

    private void ParserMap_PopStart_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PopStart");

        debugOutput("BEFORE EXIT     : PopStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PopStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PopStart.Default()");

            clearState();
            ctxt.error("Expecting '(trans)' or opening brace after pop.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.PopStart.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_PopError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PopError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PopError.entry()");

    }


    private void ParserMap_PopStart_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PopStart.LEFT_BRACE(SmcLexer.Token token)");

            clearState();
            ctxt.createActionList();

            debugOutput("EXIT TRANSITION : ParserMap.PopStart.LEFT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(sStates[ActionMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionMap::Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionMap::Start.entry()");

    }


    private void ParserMap_PopStart_LEFT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PopStart");

        debugOutput("BEFORE EXIT     : PopStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PopStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PopStart.LEFT_PAREN(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.PopStart.LEFT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PopAction_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PopAction.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PopAction.entry()");

    }


    //
    // end of ParserMap.PopStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PopError State Transitions.
    //

    private void ParserMap_PopError_Default()
    {
        final int stateId = mState.getId();


    }


    private void ParserMap_PopError_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PopError.LEFT_BRACE(SmcLexer.Token token)");

            clearState();
            ctxt.createActionList();

            debugOutput("EXIT TRANSITION : ParserMap.PopError.LEFT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(sStates[ActionMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionMap::Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionMap::Start.entry()");

    }


    private void ParserMap_PopError_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PopError");

        debugOutput("BEFORE EXIT     : PopError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PopError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PopError.RIGHT_PAREN(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.PopError.RIGHT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionStart.entry()");

    }


    //
    // end of ParserMap.PopError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PopAction State Transitions.
    //

    private void ParserMap_PopAction_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PopAction");

        debugOutput("BEFORE EXIT     : PopAction.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PopAction.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PopAction.Default()");

            clearState();
            ctxt.error("Expecting either a pop transition or closing paren.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.PopAction.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_PopError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PopError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PopError.entry()");

    }


    private void ParserMap_PopAction_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PopAction");

        debugOutput("BEFORE EXIT     : PopAction.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PopAction.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PopAction.RIGHT_PAREN(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.PopAction.RIGHT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionStart.entry()");

    }


    private void ParserMap_PopAction_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PopAction");

        debugOutput("BEFORE EXIT     : PopAction.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PopAction.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PopAction.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.setEndState(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.PopAction.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PopArgs_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PopArgs.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PopArgs.entry()");

    }


    //
    // end of ParserMap.PopAction State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PopArgs State Transitions.
    //

    private void ParserMap_PopArgs_COMMA(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PopArgs");

        debugOutput("BEFORE EXIT     : PopArgs.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PopArgs.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PopArgs.COMMA(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.PopArgs.COMMA(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_PopArgsEnd_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PopArgsEnd.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PopArgsEnd.entry()");

    }


    private void ParserMap_PopArgs_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PopArgs");

        debugOutput("BEFORE EXIT     : PopArgs.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PopArgs.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PopArgs.Default()");

            clearState();
            ctxt.error("Pop transition missing closing paren.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.PopArgs.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_PopError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : PopError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : PopError.entry()");

    }


    private void ParserMap_PopArgs_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PopArgs");

        debugOutput("BEFORE EXIT     : PopArgs.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PopArgs.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PopArgs.RIGHT_PAREN(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParserMap.PopArgs.RIGHT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionStart.entry()");

    }


    //
    // end of ParserMap.PopArgs State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PopArgsEnd State Entry/Exit Actions.
    //

    private void ParserMap_PopArgsEnd__Entry_()
    {
        ctxt.setRawMode("(", ")");
    }

    private void ParserMap_PopArgsEnd__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParserMap.PopArgsEnd State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PopArgsEnd State Transitions.
    //

    private void ParserMap_PopArgsEnd_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.PopArgsEnd");

        debugOutput("BEFORE EXIT     : PopArgsEnd.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PopArgsEnd.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.PopArgsEnd.SOURCE(SmcLexer.Token token)");

            clearState();
            ctxt.setPopArgs(token.getValue());

            debugOutput("EXIT TRANSITION : ParserMap.PopArgsEnd.SOURCE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionStart_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionStart.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionStart.entry()");

    }


    //
    // end of ParserMap.PopArgsEnd State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.ActionStart State Transitions.
    //

    private void ParserMap_ActionStart_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.ActionStart");

        debugOutput("BEFORE EXIT     : ActionStart.exit()");

        exitState();

        debugOutput("AFTER EXIT      : ActionStart.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.ActionStart.Default()");

            clearState();
            ctxt.error("An opening brace must proceed any action definitions.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParserMap.ActionStart.Default()");
        }
        finally
        {
            setState(sStates[ParserMap_ActionStartError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionStartError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionStartError.entry()");

    }


    private void ParserMap_ActionStart_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.ActionStart.LEFT_BRACE(SmcLexer.Token token)");

            clearState();
            ctxt.createActionList();

            debugOutput("EXIT TRANSITION : ParserMap.ActionStart.LEFT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(sStates[ActionMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionMap::Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionMap::Start.entry()");

    }


    //
    // end of ParserMap.ActionStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.ActionEnd State Transitions.
    //

    private void ParserMap_ActionEnd_actionsDone(List<SmcAction> actions, int lineNumber)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.ActionEnd");

        debugOutput("BEFORE EXIT     : ActionEnd.exit()");

        exitState();

        debugOutput("AFTER EXIT      : ActionEnd.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.ActionEnd.actionsDone(List<SmcAction> actions, int lineNumber)");

            clearState();
            ctxt.setActions(actions);
            ctxt.addGuard();
            ctxt.addTransition();

            debugOutput("EXIT TRANSITION : ParserMap.ActionEnd.actionsDone(List<SmcAction> actions, int lineNumber)");
        }
        finally
        {
            setState(sStates[ParserMap_Transitions_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Transitions.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Transitions.entry()");

    }


    private void ParserMap_ActionEnd_actionsError()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParserMap.ActionEnd");

        debugOutput("BEFORE EXIT     : ActionEnd.exit()");

        exitState();

        debugOutput("AFTER EXIT      : ActionEnd.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.ActionEnd.actionsError()");


            debugOutput("EXIT TRANSITION : ParserMap.ActionEnd.actionsError()");
        }
        finally
        {
            setState(sStates[ParserMap_Transitions_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Transitions.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Transitions.entry()");

    }


    //
    // end of ParserMap.ActionEnd State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.ActionStartError State Transitions.
    //

    private void ParserMap_ActionStartError_Default()
    {
        final int stateId = mState.getId();


    }


    private void ParserMap_ActionStartError_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ParserMap.ActionStartError.LEFT_BRACE(SmcLexer.Token token)");

            clearState();
            ctxt.createActionList();

            debugOutput("EXIT TRANSITION : ParserMap.ActionStartError.LEFT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(sStates[ActionMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionMap::Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionMap::Start.entry()");

    }


    //
    // end of ParserMap.ActionStartError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.Start State Entry/Exit Actions.
    //

    private void ParamMap_Start__Entry_()
    {
        ctxt.createParamList();
    }

    //
    // end of ParamMap.Start State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.Start State Transitions.
    //

    private void ParamMap_Start_DOLLAR(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.getTargetLanguage() == TargetLanguage.PERL ||
       ctxt.getTargetLanguage() == TargetLanguage.PHP ||
       ctxt.getTargetLanguage() == TargetLanguage.GRAPH ||
       ctxt.getTargetLanguage() == TargetLanguage.TABLE)
        {
            debugOutput("LEAVING STATE   : ParamMap.Start");

            debugOutput("BEFORE EXIT     : Start.exit()");

            exitState();

            debugOutput("AFTER EXIT      : Start.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParamMap.Start.DOLLAR(SmcLexer.Token token)");

                // No actions.

                debugOutput("EXIT TRANSITION : ParamMap.Start.DOLLAR(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParamMap_Dollar_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : Dollar.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : Dollar.entry()");
        }
        else
        {
            ParamMap_Start_Default();
        }

    }


    private void ParamMap_Start_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParamMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParamMap.Start.Default()");

            clearState();
            ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParamMap.Start.Default()");
        }
        finally
        {
            setState(sStates[ParamMap_Error_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Error.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Error.entry()");

    }


    private void ParamMap_Start_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParamMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParamMap.Start.RIGHT_PAREN(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParamMap.Start.RIGHT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            popState();
        }


        paramsDone(
            ctxt.getParamList(),
            token.getLineNumber());

    }


    private void ParamMap_Start_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParamMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParamMap.Start.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.createParameter(token.getValue(), token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParamMap.Start.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParamMap_ParamSeparator_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ParamSeparator.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ParamSeparator.entry()");

    }


    //
    // end of ParamMap.Start State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.Dollar State Transitions.
    //

    private void ParamMap_Dollar_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParamMap.Dollar");

        debugOutput("BEFORE EXIT     : Dollar.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Dollar.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParamMap.Dollar.Default()");

            clearState();
            ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParamMap.Dollar.Default()");
        }
        finally
        {
            setState(sStates[ParamMap_Error_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Error.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Error.entry()");

    }


    private void ParamMap_Dollar_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParamMap.Dollar");

        debugOutput("BEFORE EXIT     : Dollar.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Dollar.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParamMap.Dollar.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.createParameter("$" + token.getValue(), token.getLineNumber());

            debugOutput("EXIT TRANSITION : ParamMap.Dollar.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParamMap_ParamSeparator_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ParamSeparator.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ParamSeparator.entry()");

    }


    //
    // end of ParamMap.Dollar State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.ParamSeparator State Transitions.
    //

    private void ParamMap_ParamSeparator_COLON(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParamMap.ParamSeparator");

        debugOutput("BEFORE EXIT     : ParamSeparator.exit()");

        exitState();

        debugOutput("AFTER EXIT      : ParamSeparator.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParamMap.ParamSeparator.COLON(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParamMap.ParamSeparator.COLON(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParamMap_ParamType_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ParamType.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ParamType.entry()");

    }


    private void ParamMap_ParamSeparator_COMMA(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.getTargetLanguage() == TargetLanguage.TCL ||
       ctxt.getTargetLanguage() == TargetLanguage.GROOVY ||
       ctxt.getTargetLanguage() == TargetLanguage.JS ||
       ctxt.getTargetLanguage() == TargetLanguage.LUA ||
       ctxt.getTargetLanguage() == TargetLanguage.PERL ||
       ctxt.getTargetLanguage() == TargetLanguage.PHP ||
       ctxt.getTargetLanguage() == TargetLanguage.PYTHON ||
       ctxt.getTargetLanguage() == TargetLanguage.RUBY ||
       ctxt.getTargetLanguage() == TargetLanguage.GRAPH ||
       ctxt.getTargetLanguage() == TargetLanguage.TABLE)
        {
            debugOutput("LEAVING STATE   : ParamMap.ParamSeparator");

            debugOutput("BEFORE EXIT     : ParamSeparator.exit()");

            exitState();

            debugOutput("AFTER EXIT      : ParamSeparator.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParamMap.ParamSeparator.COMMA(SmcLexer.Token token)");

                clearState();
                ctxt.addParameter();

                debugOutput("EXIT TRANSITION : ParamMap.ParamSeparator.COMMA(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParamMap_Start_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : Start.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : Start.entry()");
        }
        else
        {
            debugOutput("LEAVING STATE   : ParamMap.ParamSeparator");

            debugOutput("BEFORE EXIT     : ParamSeparator.exit()");

            exitState();

            debugOutput("AFTER EXIT      : ParamSeparator.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParamMap.ParamSeparator.COMMA(SmcLexer.Token token)");

                clearState();
                ctxt.error("Parameter type missing.", token.getLineNumber());

                debugOutput("EXIT TRANSITION : ParamMap.ParamSeparator.COMMA(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ParamMap_Error_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : Error.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : Error.entry()");
        }
    }


    private void ParamMap_ParamSeparator_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParamMap.ParamSeparator");

        debugOutput("BEFORE EXIT     : ParamSeparator.exit()");

        exitState();

        debugOutput("AFTER EXIT      : ParamSeparator.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParamMap.ParamSeparator.Default()");

            clearState();
            ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParamMap.ParamSeparator.Default()");
        }
        finally
        {
            setState(sStates[ParamMap_Error_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Error.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Error.entry()");

    }


    private void ParamMap_ParamSeparator_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.getTargetLanguage() == TargetLanguage.TCL ||
       ctxt.getTargetLanguage() == TargetLanguage.GROOVY ||
       ctxt.getTargetLanguage() == TargetLanguage.JS ||
       ctxt.getTargetLanguage() == TargetLanguage.LUA ||
       ctxt.getTargetLanguage() == TargetLanguage.PERL ||
       ctxt.getTargetLanguage() == TargetLanguage.PHP ||
       ctxt.getTargetLanguage() == TargetLanguage.PYTHON ||
       ctxt.getTargetLanguage() == TargetLanguage.RUBY ||
       ctxt.getTargetLanguage() == TargetLanguage.GRAPH ||
       ctxt.getTargetLanguage() == TargetLanguage.TABLE)
        {
            debugOutput("LEAVING STATE   : ParamMap.ParamSeparator");

            debugOutput("BEFORE EXIT     : ParamSeparator.exit()");

            exitState();

            debugOutput("AFTER EXIT      : ParamSeparator.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParamMap.ParamSeparator.RIGHT_PAREN(SmcLexer.Token token)");

                clearState();
                ctxt.addParameter();

                debugOutput("EXIT TRANSITION : ParamMap.ParamSeparator.RIGHT_PAREN(SmcLexer.Token token)");
            }
            finally
            {
                popState();
            }


            paramsDone(
            ctxt.getParamList(),
            token.getLineNumber());
        }
        else
        {
            debugOutput("LEAVING STATE   : ParamMap.ParamSeparator");

            debugOutput("BEFORE EXIT     : ParamSeparator.exit()");

            exitState();

            debugOutput("AFTER EXIT      : ParamSeparator.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ParamMap.ParamSeparator.RIGHT_PAREN(SmcLexer.Token token)");

                clearState();
                ctxt.error("Parameter type missing.", token.getLineNumber());

                debugOutput("EXIT TRANSITION : ParamMap.ParamSeparator.RIGHT_PAREN(SmcLexer.Token token)");
            }
            finally
            {
                popState();
            }


            paramsError(
            ctxt.getParamList(),
            token.getLineNumber());
        }
    }


    //
    // end of ParamMap.ParamSeparator State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.ParamType State Entry/Exit Actions.
    //

    private void ParamMap_ParamType__Entry_()
    {
        ctxt.setRawMode2();
    }

    private void ParamMap_ParamType__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParamMap.ParamType State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.ParamType State Transitions.
    //

    private void ParamMap_ParamType_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParamMap.ParamType");

        debugOutput("BEFORE EXIT     : ParamType.exit()");

        exitState();

        debugOutput("AFTER EXIT      : ParamType.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParamMap.ParamType.SOURCE(SmcLexer.Token token)");

            clearState();
            ctxt.setParamType(token.getValue());

            debugOutput("EXIT TRANSITION : ParamMap.ParamType.SOURCE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParamMap_NextParam_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : NextParam.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : NextParam.entry()");

    }


    //
    // end of ParamMap.ParamType State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.NextParam State Transitions.
    //

    private void ParamMap_NextParam_COMMA(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParamMap.NextParam");

        debugOutput("BEFORE EXIT     : NextParam.exit()");

        exitState();

        debugOutput("AFTER EXIT      : NextParam.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParamMap.NextParam.COMMA(SmcLexer.Token token)");

            clearState();
            ctxt.addParameter();

            debugOutput("EXIT TRANSITION : ParamMap.NextParam.COMMA(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ParamMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Start.entry()");

    }


    private void ParamMap_NextParam_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParamMap.NextParam");

        debugOutput("BEFORE EXIT     : NextParam.exit()");

        exitState();

        debugOutput("AFTER EXIT      : NextParam.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParamMap.NextParam.Default()");

            clearState();
            ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ParamMap.NextParam.Default()");
        }
        finally
        {
            setState(sStates[ParamMap_Error_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Error.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Error.entry()");

    }


    private void ParamMap_NextParam_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParamMap.NextParam");

        debugOutput("BEFORE EXIT     : NextParam.exit()");

        exitState();

        debugOutput("AFTER EXIT      : NextParam.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParamMap.NextParam.RIGHT_PAREN(SmcLexer.Token token)");

            clearState();
            ctxt.addParameter();

            debugOutput("EXIT TRANSITION : ParamMap.NextParam.RIGHT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            popState();
        }


        paramsDone(
            ctxt.getParamList(),
            token.getLineNumber());

    }


    //
    // end of ParamMap.NextParam State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.Error State Entry/Exit Actions.
    //

    private void ParamMap_Error__Entry_()
    {
        ctxt.setRawMode("(", ")");
        ctxt.clearParameter();
    }

    private void ParamMap_Error__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParamMap.Error State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.Error State Transitions.
    //

    private void ParamMap_Error_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ParamMap.Error");

        debugOutput("BEFORE EXIT     : Error.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Error.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ParamMap.Error.SOURCE(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ParamMap.Error.SOURCE(SmcLexer.Token token)");
        }
        finally
        {
            popState();
        }


        paramsError(
            ctxt.getParamList(),
            token.getLineNumber());

    }


    //
    // end of ParamMap.Error State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ActionMap.Start State Transitions.
    //

    private void ActionMap_Start_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ActionMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ActionMap.Start.Default()");

            clearState();
            ctxt.clearActions();
            ctxt.error("Expecting either a method name or a closing brace", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ActionMap.Start.Default()");
        }
        finally
        {
            setState(sStates[ActionMap_ActionError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionError.entry()");

    }


    private void ActionMap_Start_RIGHT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ActionMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ActionMap.Start.RIGHT_BRACE(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ActionMap.Start.RIGHT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            popState();
        }


        actionsDone(
            ctxt.getActionList(),
            token.getLineNumber());

    }


    private void ActionMap_Start_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ActionMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ActionMap.Start.WORD(SmcLexer.Token token)");

            clearState();
            ctxt.createAction(token.getValue(), token.getLineNumber());

            debugOutput("EXIT TRANSITION : ActionMap.Start.WORD(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ActionMap_ActionName_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionName.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionName.entry()");

    }


    //
    // end of ActionMap.Start State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ActionMap.ActionName State Transitions.
    //

    private void ActionMap_ActionName_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ActionMap.ActionName");

        debugOutput("BEFORE EXIT     : ActionName.exit()");

        exitState();

        debugOutput("AFTER EXIT      : ActionName.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ActionMap.ActionName.Default()");

            clearState();
            ctxt.clearActions();
            ctxt.error("Expecting an open paren after the method name", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ActionMap.ActionName.Default()");
        }
        finally
        {
            setState(sStates[ActionMap_ActionError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionError.entry()");

    }


    private void ActionMap_ActionName_EQUAL(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.getTargetLanguage() != TargetLanguage.GRAPH &&
       ctxt.getTargetLanguage() != TargetLanguage.C_SHARP &&
       ctxt.getTargetLanguage() != TargetLanguage.GROOVY &&
       ctxt.getTargetLanguage() != TargetLanguage.JS &&
       ctxt.getTargetLanguage() != TargetLanguage.LUA &&
       ctxt.getTargetLanguage() != TargetLanguage.PERL &&
       ctxt.getTargetLanguage() != TargetLanguage.PYTHON &&
       ctxt.getTargetLanguage() != TargetLanguage.RUBY &&
       ctxt.getTargetLanguage() != TargetLanguage.SCALA &&
       ctxt.getTargetLanguage() != TargetLanguage.VB &&
       ctxt.getTargetLanguage() != TargetLanguage.TABLE)
        {
            debugOutput("LEAVING STATE   : ActionMap.ActionName");

            debugOutput("BEFORE EXIT     : ActionName.exit()");

            exitState();

            debugOutput("AFTER EXIT      : ActionName.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ActionMap.ActionName.EQUAL(SmcLexer.Token token)");

                clearState();
                ctxt.clearActions();
                ctxt.error("'=' property assignment may only be used with -vb, -csharp or -graph", token.getLineNumber());

                debugOutput("EXIT TRANSITION : ActionMap.ActionName.EQUAL(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ActionMap_ActionError_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : ActionError.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : ActionError.entry()");
        }
        else
        {
            debugOutput("LEAVING STATE   : ActionMap.ActionName");

            debugOutput("BEFORE EXIT     : ActionName.exit()");

            exitState();

            debugOutput("AFTER EXIT      : ActionName.exit()");

            try
            {
                debugOutput("ENTER TRANSITION: ActionMap.ActionName.EQUAL(SmcLexer.Token token)");

                clearState();
                ctxt.setProperty(true);
                ctxt.createArgList();

                debugOutput("EXIT TRANSITION : ActionMap.ActionName.EQUAL(SmcLexer.Token token)");
            }
            finally
            {
                setState(sStates[ActionMap_PropertyAssignment_STATE_ID]);
            }


            debugOutput("BEFORE ENTRY    : PropertyAssignment.entry()");

            enterState();

            debugOutput("AFTER ENTRY     : PropertyAssignment.entry()");
        }
    }


    private void ActionMap_ActionName_LEFT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            debugOutput("ENTER TRANSITION: ActionMap.ActionName.LEFT_PAREN(SmcLexer.Token token)");

            clearState();
            ctxt.createArgList();

            debugOutput("EXIT TRANSITION : ActionMap.ActionName.LEFT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ActionMap_ActionArgs_STATE_ID]);
            enterState();
            pushState(sStates[ArgsMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ArgsMap::Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ArgsMap::Start.entry()");

    }


    //
    // end of ActionMap.ActionName State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ActionMap.ActionArgs State Transitions.
    //

    private void ActionMap_ActionArgs_argsDone(List<String> args)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ActionMap.ActionArgs");

        debugOutput("BEFORE EXIT     : ActionArgs.exit()");

        exitState();

        debugOutput("AFTER EXIT      : ActionArgs.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ActionMap.ActionArgs.argsDone(List<String> args)");

            clearState();
            ctxt.setActionArgs(args);

            debugOutput("EXIT TRANSITION : ActionMap.ActionArgs.argsDone(List<String> args)");
        }
        finally
        {
            setState(sStates[ActionMap_ActionEnd_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionEnd.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionEnd.entry()");

    }


    private void ActionMap_ActionArgs_argsError()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ActionMap.ActionArgs");

        debugOutput("BEFORE EXIT     : ActionArgs.exit()");

        exitState();

        debugOutput("AFTER EXIT      : ActionArgs.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ActionMap.ActionArgs.argsError()");


            debugOutput("EXIT TRANSITION : ActionMap.ActionArgs.argsError()");
        }
        finally
        {
            setState(sStates[ActionMap_ActionError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionError.entry()");

    }


    //
    // end of ActionMap.ActionArgs State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ActionMap.ActionEnd State Transitions.
    //

    private void ActionMap_ActionEnd_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ActionMap.ActionEnd");

        debugOutput("BEFORE EXIT     : ActionEnd.exit()");

        exitState();

        debugOutput("AFTER EXIT      : ActionEnd.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ActionMap.ActionEnd.Default()");

            clearState();
            ctxt.error("Expecting a ';' after closing paren", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ActionMap.ActionEnd.Default()");
        }
        finally
        {
            setState(sStates[ActionMap_ActionError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionError.entry()");

    }


    private void ActionMap_ActionEnd_SEMICOLON(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ActionMap.ActionEnd");

        debugOutput("BEFORE EXIT     : ActionEnd.exit()");

        exitState();

        debugOutput("AFTER EXIT      : ActionEnd.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ActionMap.ActionEnd.SEMICOLON(SmcLexer.Token token)");

            clearState();
            ctxt.addAction();

            debugOutput("EXIT TRANSITION : ActionMap.ActionEnd.SEMICOLON(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ActionMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Start.entry()");

    }


    //
    // end of ActionMap.ActionEnd State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ActionMap.PropertyAssignment State Entry/Exit Actions.
    //

    private void ActionMap_PropertyAssignment__Entry_()
    {
        ctxt.setRawMode(";");
    }

    private void ActionMap_PropertyAssignment__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ActionMap.PropertyAssignment State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ActionMap.PropertyAssignment State Transitions.
    //

    private void ActionMap_PropertyAssignment_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ActionMap.PropertyAssignment");

        debugOutput("BEFORE EXIT     : PropertyAssignment.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PropertyAssignment.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ActionMap.PropertyAssignment.Default()");

            clearState();
            ctxt.error("Missing ';' at end of property assignment", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ActionMap.PropertyAssignment.Default()");
        }
        finally
        {
            setState(sStates[ActionMap_ActionError_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : ActionError.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : ActionError.entry()");

    }


    private void ActionMap_PropertyAssignment_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ActionMap.PropertyAssignment");

        debugOutput("BEFORE EXIT     : PropertyAssignment.exit()");

        exitState();

        debugOutput("AFTER EXIT      : PropertyAssignment.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ActionMap.PropertyAssignment.SOURCE(SmcLexer.Token token)");

            clearState();
            ctxt.createArgument(token.getValue(), token.getLineNumber());
            ctxt.addArgument();
            ctxt.setActionArgs(ctxt.getArgsList());
            ctxt.addAction();

            debugOutput("EXIT TRANSITION : ActionMap.PropertyAssignment.SOURCE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ActionMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Start.entry()");

    }


    //
    // end of ActionMap.PropertyAssignment State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ActionMap.ActionError State Transitions.
    //

    private void ActionMap_ActionError_Default()
    {
        final int stateId = mState.getId();


    }


    private void ActionMap_ActionError_RIGHT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ActionMap.ActionError");

        debugOutput("BEFORE EXIT     : ActionError.exit()");

        exitState();

        debugOutput("AFTER EXIT      : ActionError.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ActionMap.ActionError.RIGHT_BRACE(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ActionMap.ActionError.RIGHT_BRACE(SmcLexer.Token token)");
        }
        finally
        {
            popState();
        }


        actionsError();

    }


    //
    // end of ActionMap.ActionError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ArgsMap.Start State Entry/Exit Actions.
    //

    private void ArgsMap_Start__Entry_()
    {
        ctxt.setRawMode2();
    }

    private void ArgsMap_Start__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ArgsMap.Start State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ArgsMap.Start State Transitions.
    //

    private void ArgsMap_Start_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ArgsMap.Start");

        debugOutput("BEFORE EXIT     : Start.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Start.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ArgsMap.Start.SOURCE(SmcLexer.Token token)");

            clearState();
            ctxt.createArgument(token.getValue(), token.getLineNumber());

            debugOutput("EXIT TRANSITION : ArgsMap.Start.SOURCE(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ArgsMap_NextArg_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : NextArg.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : NextArg.entry()");

    }


    //
    // end of ArgsMap.Start State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ArgsMap.NextArg State Transitions.
    //

    private void ArgsMap_NextArg_COMMA(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ArgsMap.NextArg");

        debugOutput("BEFORE EXIT     : NextArg.exit()");

        exitState();

        debugOutput("AFTER EXIT      : NextArg.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ArgsMap.NextArg.COMMA(SmcLexer.Token token)");

            clearState();
            ctxt.addArgument();

            debugOutput("EXIT TRANSITION : ArgsMap.NextArg.COMMA(SmcLexer.Token token)");
        }
        finally
        {
            setState(sStates[ArgsMap_Start_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Start.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Start.entry()");

    }


    private void ArgsMap_NextArg_Default()
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ArgsMap.NextArg");

        debugOutput("BEFORE EXIT     : NextArg.exit()");

        exitState();

        debugOutput("AFTER EXIT      : NextArg.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ArgsMap.NextArg.Default()");

            clearState();
            ctxt.error("Missing ',' or closing paren after argument.", ctxt.getLineNumber());

            debugOutput("EXIT TRANSITION : ArgsMap.NextArg.Default()");
        }
        finally
        {
            setState(sStates[ArgsMap_Error_STATE_ID]);
        }


        debugOutput("BEFORE ENTRY    : Error.entry()");

        enterState();

        debugOutput("AFTER ENTRY     : Error.entry()");

    }


    private void ArgsMap_NextArg_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ArgsMap.NextArg");

        debugOutput("BEFORE EXIT     : NextArg.exit()");

        exitState();

        debugOutput("AFTER EXIT      : NextArg.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ArgsMap.NextArg.RIGHT_PAREN(SmcLexer.Token token)");

            clearState();
            ctxt.addArgument();

            debugOutput("EXIT TRANSITION : ArgsMap.NextArg.RIGHT_PAREN(SmcLexer.Token token)");
        }
        finally
        {
            popState();
        }


        argsDone( ctxt.getArgsList());

    }


    //
    // end of ArgsMap.NextArg State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ArgsMap.Error State Entry/Exit Actions.
    //

    private void ArgsMap_Error__Entry_()
    {
        ctxt.setRawMode("{", "}");
        ctxt.clearArguments();
    }

    private void ArgsMap_Error__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ArgsMap.Error State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ArgsMap.Error State Transitions.
    //

    private void ArgsMap_Error_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        debugOutput("LEAVING STATE   : ArgsMap.Error");

        debugOutput("BEFORE EXIT     : Error.exit()");

        exitState();

        debugOutput("AFTER EXIT      : Error.exit()");

        try
        {
            debugOutput("ENTER TRANSITION: ArgsMap.Error.SOURCE(SmcLexer.Token token)");


            debugOutput("EXIT TRANSITION : ArgsMap.Error.SOURCE(SmcLexer.Token token)");
        }
        finally
        {
            popState();
        }


        argsError();

    }


    //
    // end of ArgsMap.Error State Transitions.
    //-----------------------------------------------------------

//---------------------------------------------------------------
// Member data.
//

    transient private SmcParser ctxt;

    //-----------------------------------------------------------
    // Constants.
    //

    private static final long serialVersionUID = 1L;

    public static final int ParserMap_Start_STATE_ID = 0;
    public static final int ParserMap_Context_STATE_ID = 1;
    public static final int ParserMap_StartState_STATE_ID = 2;
    public static final int ParserMap_HeaderFile_STATE_ID = 3;
    public static final int ParserMap_IncludeFile_STATE_ID = 4;
    public static final int ParserMap_Package_STATE_ID = 5;
    public static final int ParserMap_FsmClassName_STATE_ID = 6;
    public static final int ParserMap_FsmFileName_STATE_ID = 7;
    public static final int ParserMap_Import_STATE_ID = 8;
    public static final int ParserMap_Declare_STATE_ID = 9;
    public static final int ParserMap_Access_STATE_ID = 10;
    public static final int ParserMap_StartError_STATE_ID = 11;
    public static final int ParserMap_MapStart_STATE_ID = 12;
    public static final int ParserMap_MapStartError_STATE_ID = 13;
    public static final int ParserMap_MapName_STATE_ID = 14;
    public static final int ParserMap_MapStates_STATE_ID = 15;
    public static final int ParserMap_MapStatesError_STATE_ID = 16;
    public static final int ParserMap_States_STATE_ID = 17;
    public static final int ParserMap_StateStart_STATE_ID = 18;
    public static final int ParserMap_StateStartError_STATE_ID = 19;
    public static final int ParserMap_EntryStart_STATE_ID = 20;
    public static final int ParserMap_EntryEnd_STATE_ID = 21;
    public static final int ParserMap_ExitStart_STATE_ID = 22;
    public static final int ParserMap_ExitEnd_STATE_ID = 23;
    public static final int ParserMap_Transitions_STATE_ID = 24;
    public static final int ParserMap_TransError_STATE_ID = 25;
    public static final int ParserMap_TransStart_STATE_ID = 26;
    public static final int ParserMap_TransStartError_STATE_ID = 27;
    public static final int ParserMap_TransParams_STATE_ID = 28;
    public static final int ParserMap_TransNext_STATE_ID = 29;
    public static final int ParserMap_TransNextError_STATE_ID = 30;
    public static final int ParserMap_TransGuard_STATE_ID = 31;
    public static final int ParserMap_EndState_STATE_ID = 32;
    public static final int ParserMap_EndStateError_STATE_ID = 33;
    public static final int ParserMap_SimpleTrans_STATE_ID = 34;
    public static final int ParserMap_PushTransition_STATE_ID = 35;
    public static final int ParserMap_PushStart_STATE_ID = 36;
    public static final int ParserMap_PushError_STATE_ID = 37;
    public static final int ParserMap_PushMap_STATE_ID = 38;
    public static final int ParserMap_PushEnd_STATE_ID = 39;
    public static final int ParserMap_JumpStart_STATE_ID = 40;
    public static final int ParserMap_JumpError_STATE_ID = 41;
    public static final int ParserMap_JumpMap_STATE_ID = 42;
    public static final int ParserMap_JumpEnd_STATE_ID = 43;
    public static final int ParserMap_PopStart_STATE_ID = 44;
    public static final int ParserMap_PopError_STATE_ID = 45;
    public static final int ParserMap_PopAction_STATE_ID = 46;
    public static final int ParserMap_PopArgs_STATE_ID = 47;
    public static final int ParserMap_PopArgsEnd_STATE_ID = 48;
    public static final int ParserMap_ActionStart_STATE_ID = 49;
    public static final int ParserMap_ActionEnd_STATE_ID = 50;
    public static final int ParserMap_ActionStartError_STATE_ID = 51;

    public static final int ParamMap_Start_STATE_ID = 52;
    public static final int ParamMap_Dollar_STATE_ID = 53;
    public static final int ParamMap_ParamSeparator_STATE_ID = 54;
    public static final int ParamMap_ParamType_STATE_ID = 55;
    public static final int ParamMap_NextParam_STATE_ID = 56;
    public static final int ParamMap_Error_STATE_ID = 57;

    public static final int ActionMap_Start_STATE_ID = 58;
    public static final int ActionMap_ActionName_STATE_ID = 59;
    public static final int ActionMap_ActionArgs_STATE_ID = 60;
    public static final int ActionMap_ActionEnd_STATE_ID = 61;
    public static final int ActionMap_PropertyAssignment_STATE_ID = 62;
    public static final int ActionMap_ActionError_STATE_ID = 63;

    public static final int ArgsMap_Start_STATE_ID = 64;
    public static final int ArgsMap_NextArg_STATE_ID = 65;
    public static final int ArgsMap_Error_STATE_ID = 66;

    private static final int STATE_COUNT = 67;

    private static final int ACCESS11_TRANSITION_ID = 1;
    private static final int CLASS_NAME3_TRANSITION_ID = 2;
    private static final int COLON34_TRANSITION_ID = 3;
    private static final int COMMA32_TRANSITION_ID = 4;
    private static final int DECLARE10_TRANSITION_ID = 5;
    private static final int DOLLAR33_TRANSITION_ID = 6;
    private static final int ENTRY16_TRANSITION_ID = 7;
    private static final int EOD15_TRANSITION_ID = 8;
    private static final int EQUAL19_TRANSITION_ID = 9;
    private static final int EXIT17_TRANSITION_ID = 10;
    private static final int FSM_CLASS_NAME4_TRANSITION_ID = 11;
    private static final int FSM_FILE_NAME5_TRANSITION_ID = 12;
    private static final int HEADER_FILE6_TRANSITION_ID = 13;
    private static final int IMPORT9_TRANSITION_ID = 14;
    private static final int INCLUDE_FILE7_TRANSITION_ID = 15;
    private static final int JUMP27_TRANSITION_ID = 16;
    private static final int LEFT_BRACE18_TRANSITION_ID = 17;
    private static final int LEFT_BRACKET24_TRANSITION_ID = 18;
    private static final int LEFT_PAREN23_TRANSITION_ID = 19;
    private static final int MAP_NAME12_TRANSITION_ID = 20;
    private static final int PACKAGE_NAME8_TRANSITION_ID = 21;
    private static final int POP26_TRANSITION_ID = 22;
    private static final int PUSH25_TRANSITION_ID = 23;
    private static final int RIGHT_BRACE22_TRANSITION_ID = 24;
    private static final int RIGHT_PAREN31_TRANSITION_ID = 25;
    private static final int SEMICOLON37_TRANSITION_ID = 26;
    private static final int SLASH30_TRANSITION_ID = 27;
    private static final int SOURCE1_TRANSITION_ID = 28;
    private static final int START_STATE2_TRANSITION_ID = 29;
    private static final int WORD14_TRANSITION_ID = 30;
    private static final int actionsDone20_TRANSITION_ID = 31;
    private static final int actionsError21_TRANSITION_ID = 32;
    private static final int argsDone35_TRANSITION_ID = 33;
    private static final int argsError36_TRANSITION_ID = 34;
    private static final int paramsDone28_TRANSITION_ID = 35;
    private static final int paramsError29_TRANSITION_ID = 36;

    private static final int TRANSITION_COUNT = 37;

    private static final MethodType[] TRANSITION_TYPES =
    {
        NO_ARGS_TYPE,
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, List.class, int.class),
        NO_ARGS_TYPE,
        MethodType.methodType(void.class, List.class),
        NO_ARGS_TYPE,
        MethodType.methodType(void.class, List.class, int.class),
        MethodType.methodType(void.class, List.class, int.class)
    };

    private static final String[] MAP_NAMES =
    {
        "ParserMap",
        "ParamMap",
        "ActionMap",
        "ArgsMap"
    };

    private static final String[][] STATE_NAMES =
    {
        new String[]
        {
            "Start",
            "Context",
            "StartState",
            "HeaderFile",
            "IncludeFile",
            "Package",
            "FsmClassName",
            "FsmFileName",
            "Import",
            "Declare",
            "Access",
            "StartError",
            "MapStart",
            "MapStartError",
            "MapName",
            "MapStates",
            "MapStatesError",
            "States",
            "StateStart",
            "StateStartError",
            "EntryStart",
            "EntryEnd",
            "ExitStart",
            "ExitEnd",
            "Transitions",
            "TransError",
            "TransStart",
            "TransStartError",
            "TransParams",
            "TransNext",
            "TransNextError",
            "TransGuard",
            "EndState",
            "EndStateError",
            "SimpleTrans",
            "PushTransition",
            "PushStart",
            "PushError",
            "PushMap",
            "PushEnd",
            "JumpStart",
            "JumpError",
            "JumpMap",
            "JumpEnd",
            "PopStart",
            "PopError",
            "PopAction",
            "PopArgs",
            "PopArgsEnd",
            "ActionStart",
            "ActionEnd",
            "ActionStartError"
        },

        new String[]
        {
            "Start",
            "Dollar",
            "ParamSeparator",
            "ParamType",
            "NextParam",
            "Error"
        },

        new String[]
        {
            "Start",
            "ActionName",
            "ActionArgs",
            "ActionEnd",
            "PropertyAssignment",
            "ActionError"
        },

        new String[]
        {
            "Start",
            "NextArg",
            "Error"
        }
    };

    private static String[][] STATE_TRANSITIONS =
    {
        new String[]
        {
            "ACCESS",
            "CLASS_NAME",
            "DECLARE",
            "Default",
            "FSM_CLASS_NAME",
            "FSM_FILE_NAME",
            "HEADER_FILE",
            "IMPORT",
            "INCLUDE_FILE",
            "MAP_NAME",
            "PACKAGE_NAME",
            "SOURCE",
            "START_STATE"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "Default",
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "Default",
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "SOURCE"
        },

        new String[]
        {
            "ACCESS",
            "CLASS_NAME",
            "DECLARE",
            "Default",
            "FSM_CLASS_NAME",
            "FSM_FILE_NAME",
            "HEADER_FILE",
            "IMPORT",
            "MAP_NAME",
            "PACKAGE_NAME",
            "START_STATE"
        },

        new String[]
        {
            "Default",
            "MAP_NAME"
        },

        new String[]
        {
            "Default",
            "MAP_NAME"
        },

        new String[]
        {
            "Default",
            "EOD",
            "WORD"
        },

        new String[]
        {
            "Default",
            "EOD",
            "WORD"
        },

        new String[]
        {
            "Default",
            "EOD",
            "MAP_NAME",
            "WORD"
        },

        new String[]
        {
            "Default",
            "ENTRY",
            "EOD",
            "EQUAL",
            "EXIT",
            "LEFT_BRACE",
            "MAP_NAME",
            "WORD"
        },

        new String[]
        {
            "Default",
            "ENTRY",
            "EXIT",
            "LEFT_BRACE"
        },

        new String[]
        {
            "Default",
            "ENTRY",
            "EXIT",
            "LEFT_BRACE"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE"
        },

        new String[]
        {
            "actionsDone",
            "actionsError"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE"
        },

        new String[]
        {
            "actionsDone",
            "actionsError"
        },

        new String[]
        {
            "Default",
            "RIGHT_BRACE",
            "WORD"
        },

        new String[]
        {
            "Default",
            "RIGHT_BRACE",
            "WORD"
        },

        new String[]
        {
            "Default",
            "JUMP",
            "LEFT_BRACKET",
            "LEFT_PAREN",
            "POP",
            "PUSH",
            "WORD"
        },

        new String[]
        {
            "Default",
            "JUMP",
            "LEFT_BRACE",
            "LEFT_BRACKET",
            "LEFT_PAREN",
            "POP",
            "PUSH",
            "RIGHT_BRACE"
        },

        new String[]
        {
            "paramsDone",
            "paramsError"
        },

        new String[]
        {
            "Default",
            "JUMP",
            "LEFT_BRACKET",
            "POP",
            "PUSH",
            "WORD"
        },

        new String[]
        {
            "Default",
            "JUMP",
            "LEFT_BRACKET",
            "LEFT_PAREN",
            "POP",
            "PUSH",
            "WORD"
        },

        new String[]
        {
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "JUMP",
            "POP",
            "PUSH",
            "WORD"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE",
            "SLASH"
        },

        new String[]
        {
            "Default",
            "PUSH"
        },

        new String[]
        {
            "Default",
            "LEFT_PAREN"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "Default",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "Default",
            "LEFT_PAREN"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "Default",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE",
            "LEFT_PAREN"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "Default",
            "RIGHT_PAREN",
            "WORD"
        },

        new String[]
        {
            "COMMA",
            "Default",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE"
        },

        new String[]
        {
            "actionsDone",
            "actionsError"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE"
        },

        new String[]
        {
            "DOLLAR",
            "Default",
            "RIGHT_PAREN",
            "WORD"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "COLON",
            "COMMA",
            "Default",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "SOURCE"
        },

        new String[]
        {
            "COMMA",
            "Default",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "RIGHT_BRACE",
            "WORD"
        },

        new String[]
        {
            "Default",
            "EQUAL",
            "LEFT_PAREN"
        },

        new String[]
        {
            "argsDone",
            "argsError"
        },

        new String[]
        {
            "Default",
            "SEMICOLON"
        },

        new String[]
        {
            "Default",
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "RIGHT_BRACE"
        },

        new String[]
        {
            "SOURCE"
        },

        new String[]
        {
            "COMMA",
            "Default",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "SOURCE"
        }
    };

    private static final String[] TRANSITION_NAMES =
    {
        "Default",
        "ACCESS",
        "CLASS_NAME",
        "COLON",
        "COMMA",
        "DECLARE",
        "DOLLAR",
        "ENTRY",
        "EOD",
        "EQUAL",
        "EXIT",
        "FSM_CLASS_NAME",
        "FSM_FILE_NAME",
        "HEADER_FILE",
        "IMPORT",
        "INCLUDE_FILE",
        "JUMP",
        "LEFT_BRACE",
        "LEFT_BRACKET",
        "LEFT_PAREN",
        "MAP_NAME",
        "PACKAGE_NAME",
        "POP",
        "PUSH",
        "RIGHT_BRACE",
        "RIGHT_PAREN",
        "SEMICOLON",
        "SLASH",
        "SOURCE",
        "START_STATE",
        "WORD",
        "actionsDone",
        "actionsError",
        "argsDone",
        "argsError",
        "paramsDone",
        "paramsError"
    };

    private static final State7[] sStates = new State7[STATE_COUNT];

    static
    {
        final Lookup lookup = MethodHandles.lookup();
        final Class<?> clazz = SmcParserContext.class;
        final int mapSize = MAP_NAMES.length;
        int stateSize;
        int mapIndex;
        int stateIndex;
        int transIndex;
        int stateId = 0;
        String mapName;
        String stateName;
        String transName;
        String methodName;
        MethodType transType;
        MethodHandle entryHandle;
        MethodHandle exitHandle;
        TransitionHandle[] transitions;

        for (mapIndex = 0; mapIndex < mapSize; ++mapIndex)
        {
            mapName = MAP_NAMES[mapIndex];
            stateSize = STATE_NAMES[mapIndex].length;

            for (stateIndex = 0; stateIndex < stateSize; ++stateIndex, ++stateId)
            {
                stateName = STATE_NAMES[mapIndex][stateIndex];
                transitions = new TransitionHandle[TRANSITION_COUNT];

                methodName = String.format(ENTRY_NAME, mapName, stateName);
                entryHandle = lookupMethod(lookup, clazz, methodName, NO_ARGS_TYPE);
                methodName = String.format(EXIT_NAME, mapName, stateName);
                exitHandle = lookupMethod(lookup, clazz, methodName, NO_ARGS_TYPE);

                for (transIndex = 1; transIndex < TRANSITION_COUNT; ++transIndex)
                {
                    transName = TRANSITION_NAMES[transIndex];
                    transType = TRANSITION_TYPES[transIndex];
                    transitions[transIndex] =
                        lookupTransition(lookup, clazz, mapName, stateName, transName, transType);
                }

                sStates[stateId] =
                    new State7(
                        String.format(STATE_NAME_FORMAT, mapName, stateName),
                        stateId,
                        entryHandle,
                        exitHandle,
                        transitions,
                        STATE_TRANSITIONS[stateId]);
            }
        }
    }
}

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
